# Python

## Todo List

**第一阶段：Python 基础语法 (建议用时：2-4 周)**

* [x] [理解变量的概念和命名规则](#变量的概念与命名规则)
* [x] 学习并掌握数字类型：整数 (`int`) 和浮点数 (`float`)
* [x] 学习并掌握字符串类型 (`str`)
* [x] 学习并掌握布尔类型 (`bool`)
* [x] 掌握不同数据类型之间的转换方法
* [x] 学习算术运算符：`+`, `-`, `*`, `/`, `//`, `%`, `**`
* [x] 学习比较运算符：`==`, `!=`, `>`, `<`, `>=`, `<=`
* [x] 学习逻辑运算符：`and`, `or`, `not`
* [x] 学习赋值运算符：`=`, `+=`, `-=`, `*=`, `/=` 等
* [x] 学习成员运算符：`in`, `not in`
* [x] 学习身份运算符：`is`, `is not`
* [x] 学习使用 `input()` 函数获取用户输入
* [ ] 学习使用 `print()` 函数输出结果
* [ ] 掌握 `print()` 函数的格式化输出 (f-strings, `.format()` 方法)
* [ ] 理解并使用 `if` 语句
* [ ] 理解并使用 `if-else` 语句
* [ ] 理解并使用 `if-elif-else` 语句
* [ ] 掌握嵌套条件语句的使用
* [ ] 理解并使用 `for` 循环 (遍历序列、使用 `range()`)
* [ ] 理解并使用 `while` 循环
* [ ] 学习循环控制语句：`break`, `continue`
* [ ] 了解循环中的 `else` 子句

**第二阶段：Python 数据结构 (建议用时：2-4 周)**

* [ ] 学习列表 (`list`) 的创建方法
* [ ] 掌握访问列表元素的方法 (索引)
* [ ] 掌握修改列表元素的方法
* [ ] 掌握删除列表元素的方法 (`del`, `pop()`, `remove()`)
* [ ] 学习列表的常用方法：`append()`, `insert()`, `sort()`, `reverse()`, `len()`, `index()`, `count()` 等
* [ ] 掌握列表的切片操作
* [ ] 理解并使用列表推导式
* [ ] 理解元组 (`tuple`) 的不可变性
* [ ] 学习元组的创建和访问方法
* [ ] 掌握元组的打包与解包
* [ ] 理解字典 (`dict`) 中键值对 (`key-value`) 的概念
* [ ] 学习字典的创建方法
* [ ] 掌握访问字典元素的方法 (通过键)
* [ ] 掌握修改字典元素的方法
* [ ] 掌握删除字典元素的方法 (`del`, `pop()`, `popitem()`)
* [ ] 学习字典的常用方法：`keys()`, `values()`, `items()`, `get()`, `update()` 等
* [ ] 理解并使用字典推导式
* [ ] 理解集合 (`set`) 的无序性和唯一性
* [ ] 学习集合的创建方法
* [ ] 掌握集合的交集、并集、差集等运算
* [ ] 学习集合的常用方法：`add()`, `remove()`, `discard()`, `pop()`, `union()`, `intersection()`, `difference()` 等
* [ ] 复习并深入学习字符串 (`str`) 的常用方法：`split()`, `join()`, `strip()`, `replace()`, `find()`, `startswith()`, `endswith()`, `upper()`, `lower()` 等
* [ ] 巩固字符串格式化方法

**第三阶段：函数与模块 (建议用时：2-3 周)**

* [ ] 学习使用 `def` 关键字定义函数
* [ ] 掌握函数的调用方法
* [ ] 理解并使用函数的位置参数
* [ ] 理解并使用函数的默认参数
* [ ] 理解并使用函数的可变参数 (`*args`)
* [ ] 理解并使用函数的关键字参数 (`**kwargs`)
* [ ] 理解并使用函数的 `return` 语句获取返回值
* [ ] 理解函数作用域：局部变量 (local) 和全局变量 (global)
* [ ] 学习 `lambda` 表达式 (匿名函数) 的定义和使用场景
* [ ] 理解递归函数的概念和基本应用 (注意避免无限递归)
* [ ] 初步了解函数式编程概念
* [ ] 学习高阶函数 `map()` 的使用
* [ ] 学习高阶函数 `filter()` 的使用
* [ ] 学习高阶函数 `reduce()` 的使用 (可能需要从 `functools` 模块导入)
* [ ] 理解模块 (`module`) 的概念和作用
* [ ] 学习导入模块：`import module_name`
* [ ] 学习导入模块中的特定部分：`from module_name import ...`
* [ ] 学习并使用 Python 内置模块，例如：
    * [ ] `math` 模块
    * [ ] `random` 模块
    * [ ] `datetime` 模块
    * [ ] `json` 模块
    * [ ] `os` 模块 (基础部分)
* [ ] 学习如何创建自己的模块文件
* [ ] 了解包 (`package`) 的概念以及如何组织多个模块

**第四阶段：面向对象编程 (OOP) (建议用时：3-5 周)**

* [ ] 理解面向对象编程 (OOP) 的基本思想
* [ ] 理解类 (`class`) 和对象 (`object`)/实例 (`instance`) 的概念
* [ ] 学习使用 `class` 关键字定义类
* [ ] 学习构造函数 `__init__()` 的作用和写法
* [ ] 理解并定义实例属性
* [ ] 理解并定义类属性
* [ ] 定义和调用实例方法
* [ ] 理解并使用 `@classmethod` 定义和调用类方法
* [ ] 理解并使用 `@staticmethod` 定义和调用静态方法
* [ ] 理解封装的概念
* [ ] 学习 Python 中的访问限制 (公有成员、名称改写实现的“私有”成员 `__`)
* [ ] 了解 `getter` 和 `setter` 方法的思想 (虽然 Python 不强制)
* [ ] 理解继承的概念和作用
* [ ] 实现单继承
* [ ] 了解和实现多继承 (注意 MRO 顺序)
* [ ] 学习方法重写 (Override)
* [ ] 学习 `super()` 函数在继承中的使用
* [ ] 理解多态的概念和在 Python 中的体现
* [ ] 学习常用的特殊方法 (魔术方法)，例如：
    * [ ] `__str__()`
    * [ ] `__repr__()`
    * [ ] `__len__()`
    * [ ] `__eq__()`

**第五阶段：文件操作与异常处理 (建议用时：1-2 周)**

* [ ] 学习使用 `open()` 函数打开文件
* [ ] 学习使用 `close()` 方法关闭文件
* [ ] 掌握使用 `with` 语句自动管理文件开关
* [ ] 了解文件模式：读 (`'r'`)、写 (`'w'`)、追加 (`'a'`)、二进制 (`'b'`) 等
* [ ] 学习读取文件内容的方法：`read()`, `readline()`, `readlines()`
* [ ] 学习写入文件内容的方法：`write()`, `writelines()`
* [ ] 了解文件指针和定位：`seek()`, `tell()`
* [ ] 学习处理 CSV 文件的基本方法 (可结合 `csv` 模块)
* [ ] 学习处理 JSON 文件的基本方法 (可结合 `json` 模块)
* [ ] 理解什么是异常以及为什么需要异常处理
* [ ] 学习使用 `try-except` 语句捕获特定类型的异常
* [ ] 学习使用 `try-except` 语句捕获所有异常 (并了解其潜在风险)
* [ ] 学习使用 `try-except-else` 语句
* [ ] 学习使用 `try-except-finally` 语句 (理解 `finally` 子句的执行时机)
* [ ] 学习使用 `raise` 语句主动抛出异常
* [ ] 了解如何定义自定义异常类

**第六阶段：常用标准库与第三方库入门 (建议用时：持续学习)**

* [ ] **标准库选学:**
    * [ ] 深入学习 `os` 模块：文件和目录操作
    * [ ] 学习 `sys` 模块：与 Python 解释器相关的变量和函数
    * [ ] 深入学习 `datetime` 模块：日期和时间的高级处理
    * [ ] 学习 `time` 模块：时间相关的函数，如延时
    * [ ] 深入学习 `json` 模块：JSON 数据的编码和解码
    * [ ] 学习 `csv` 模块：CSV 文件的读写
    * [ ] 学习 `re` 模块：正则表达式操作入门
    * [ ] 学习 `collections` 模块中的额外数据结构，如 `deque`, `Counter`, `defaultdict`
    * [ ] 了解 `urllib` 模块 (进行网络请求的基础)
    * [ ] (进阶) 初步了解 `multiprocessing` 或 `threading` 模块
* [ ] **常用第三方库入门 (根据兴趣和目标选择，需要 `pip` 安装):**
    * [ ] **数据科学方向:**
        * [ ] 学习 `NumPy` 基础：创建和操作 N 维数组
        * [ ] 学习 `Pandas` 基础：`Series` 和 `DataFrame` 的创建与基本操作
        * [ ] 学习 `Matplotlib` 或 `Seaborn` 基础：绘制简单的图表
        * [ ] (可选) 了解 `Scikit-learn` 的基本概念和用途
    * [ ] **Web 开发/爬虫方向:**
        * [ ] 学习 `Requests` 库：发送 HTTP 请求
        * [ ] 学习 `Beautiful Soup` 或 `lxml` 基础：解析 HTML/XML
        * [ ] (可选) 了解 `Scrapy` 爬虫框架的基本概念
        * [ ] (可选) 了解 `Flask` 或 `Django` Web 框架的基本概念
    * [ ] **其他方向:**
        * [ ] (图像处理) 了解 `Pillow (PIL Fork)` 库的基本图像操作
        * [ ] (计算机视觉) 了解 `OpenCV-Python` 的基本概念和用途

**第七阶段：项目实践与进阶 (持续进行)**

* [ ] 学习并使用 `Git` 进行代码版本控制 (基本命令：`clone`, `add`, `commit`, `push`, `pull`, `branch`, `merge`)
* [ ] 了解单元测试的概念
* [ ] 学习使用 `unittest` 或 `pytest` 模块编写简单的单元测试
* [ ] 学习并遵循 PEP 8 Python 代码规范
* [ ] 学习并熟练使用 IDE 的调试功能 (设置断点、单步执行、查看变量等)
* [ ] (可选) 尝试阅读一些优秀的 Python 开源项目源码
* [ ] **根据兴趣选择并完成至少一个小项目**
* [ ] **针对性深入学习:**
    * [ ] 数据结构与算法 (推荐系统学习)
    * [ ] 特定领域的 Python 应用 (如数据分析、机器学习、Web 后端、自动化脚本等)
    * [ ] Python 并发编程：线程、进程、协程 (`asyncio`)

## 变量的概念与命名规则

### 变量的概念

想象一下，你在做一个数学题，需要用到一个数字，比如圆周率 $\\pi \\approx 3.14159$。你不会每次用到它的时候都把这一长串数字写一遍，而是可能会用一个符号，比如 "pi"，来代表这个数字。在程序中，**变量 (Variable)** 就扮演着类似的角色。

简单来说，**变量就是一个用来存储数据的“标签”或“容器”**。你可以把数据（比如数字、文字、列表等）放进这个容器里，并且给这个容器贴上一个名字（就是变量名）。以后当你想使用这个数据时，只需要通过这个名字就可以找到并使用它。

**核心思想：**

1.  **存储数据：** 变量的主要目的是在内存中存储信息。
2.  **引用数据：** 通过变量名，我们可以方便地引用（访问或修改）存储在内存中的数据。
3.  **可变性：** “变量”之所以叫“变”量，是因为它存储的数据通常是可以改变的。比如，你一开始让变量 `age` 存储数字 `20`，之后可以把它改成 `21`。

**在 Python 中，当你创建一个变量时，实际上发生了两件事：**

1.  Python 会在计算机的内存中找一块空间来存放你要存储的数据。
2.  Python 会将你指定的变量名与这块内存空间关联起来（就像给这块内存贴上了标签）。

**示例：**

```python
# 创建一个名为 pi 的变量，并把浮点数 3.14159 存进去
pi = 3.14159

# 创建一个名为 message 的变量，并把字符串 "你好，世界！" 存进去
message = "你好，世界！"

# 创建一个名为 count 的变量，并把整数 10 存进去
count = 10

# 之后可以修改变量中存储的数据
count = count + 5  # 现在 count 存储的是 15
```

在这个例子中：

  * `pi` 是一个变量名，它指向内存中存储 `3.14159` 这个值的地方。
  * `message` 是一个变量名，它指向内存中存储 `"你好，世界！"` 这个文本的地方。
  * `count` 是一个变量名，它一开始指向 `10`，后来指向了 `15`。

**Python 变量的特点：**

  * **动态类型 (Dynamically Typed)：** 你不需要在使用变量前显式声明它的类型（比如告诉 Python 这个变量只能存数字或者只能存文字）。Python 解释器会在你给变量赋值时自动判断其类型。
    ```python
    my_variable = 10      # my_variable 是整数类型
    my_variable = "Hello" # 现在 my_variable 变成了字符串类型 (这是允许的)
    ```
  * **变量只是一个引用：** 变量名本身不包含数据，它只是指向数据在内存中的位置。这有点像你有一个朋友的地址，地址本身不是你朋友，但通过地址你可以找到他。

### 变量的命名规则

给变量起一个好名字非常重要，它能让你的代码更容易阅读和理解。Python 对变量名有一些强制性的规则和一些约定俗成的规范。

**强制性规则 (必须遵守，否则程序会报错)：**

1.  **字符组成：** 变量名只能包含 **字母 (a-z, A-Z)**、**数字 (0-9)** 和 **下划线 (`_`)**。
      * 有效示例：`my_name`, `age1`, `_value`
2.  **开头字符：** 变量名 **不能以数字开头**。
      * 无效示例：`1name` (会报错)
      * 有效示例：`name1`
3.  **区分大小写：** Python 是大小写敏感的。这意味着 `myVariable` 和 `myvariable` 是两个不同的变量。
      * `age = 20` 和 `Age = 30` 是不同的变量。
4.  **不能是关键字 (Keywords)：** Python 有一些保留字，它们有特殊的含义，不能用作变量名。你可以通过以下方式查看 Python 的关键字列表：
    
    ```python
    import keyword
    print(keyword.kwlist)
    ```
    常见的关键字有：`if`, `else`, `for`, `while`, `def`, `class`, `return`, `True`, `False`, `None` 等。
      * 无效示例：`if = 10` (会报错)

**命名规范和建议 (非强制，但强烈推荐遵守，以提高代码可读性)：**

1.  **见名知意 (Descriptive Names)：** 变量名应该清晰地描述它所存储的数据的含义。
      * 推荐：`user_name`, `age`, `total_count`
      * 不推荐：`a`, `b`, `x1`, `var2` (除非在非常简短、上下文清晰的临时代码中)
2.  **使用下划线分隔单词 (Snake Case)：** 这是 Python 社区最推荐的变量命名风格，即所有字母小写，单词之间用下划线连接。
      * 推荐：`first_name`, `item_list`, `http_response_code`
      * 也可以用驼峰命名法 (Camel Case)，但蛇形命名法在 Python 中更普遍，特别是对于变量和函数名。
          * 小驼峰 (lowerCamelCase): `firstName`, `itemList`
          * 大驼峰 (UpperCamelCase/PascalCase): `FirstName`, `ItemList` (通常用于类名)
3.  **避免使用容易混淆的字符：** 避免使用小写字母 `l` (elle)、大写字母 `O` (oh) 和数字 `0` (zero)、大写字母 `I` (eye) 和数字 `1` (one)，因为它们在某些字体下看起来很相似。
4.  **简洁明了：** 在保证见名知意的前提下，尽量让变量名简洁。
5.  **一致性：** 在一个项目中，保持统一的命名风格。
6.  **避免使用 Python 内置函数或类型的名称作为变量名：** 虽然 Python 允许你这样做（因为它们不是严格意义上的关键字），但这会导致你无法再调用原来的内置函数或使用该类型。
      * 不推荐：`str = "hello"`, `list = [1, 2, 3]`, `print = "my_printer"` (这样做之后，你就不能使用内置的 `str()` 函数、`list()` 类型或 `print()` 函数了，除非你 `del` 掉你创建的同名变量)。

**有效和无效的变量名示例：**

  * **有效的变量名：**
      * `name`
      * `user_age`
      * `_count` (以下划线开头的变量通常有特殊含义，比如表示内部使用，但语法上是允许的)
      * `MAX_CONNECTIONS` (全大写通常用来表示常量)
      * `studentName` (小驼峰命名法)
      * `CarModel` (大驼峰命名法，通常用于类名)
      * `item1`
  * **无效的变量名：**
      * `2items` (不能以数字开头)
      * `user name` (不能包含空格)
      * `my-variable` (不能包含连字符 `-`)
      * `class` (是关键字)
      * `global@value` (不能包含特殊符号 `@`)

**总结一下：**

  * **变量** 是给内存中的数据贴的标签，方便我们引用和修改数据。
  * 命名时 **必须** 遵守：只能用字母、数字、下划线；不能数字开头；区分大小写；不能用关键字。
  * 命名时 **推荐** 遵守：见名知意；使用蛇形命名法 (如 `my_variable`)；保持简洁和一致性；避免覆盖内置函数名。

理解并遵循这些概念和规则，将帮助你编写出更清晰、更易于维护的 Python 代码。

## 整数 (int) 与浮点数 (float)

### 1. 什么是整数 (int) 和浮点数 (float)

在 Python 中，数字类型用于表示数值。最常用的两种数字类型是：

- **整数 (Integer, `int`)**: 表示不带小数点的正数、负数或零。例如：-2, 0, 10, 1000000。在 Python 3 中，整数的大小是 **没有限制** 的，只受限于你的计算机内存。
- **浮点数 (Floating-Point Number, `float`)**: 表示带小数点的数字。例如：3.14, -0.001, 2.0, 1.23e5 (科学计数法，表示 1.23 x 10^5^)。浮点数通常用于表示实数，但它们在计算机内部的表示方式决定了可能存在 **精度问题**。

------

### 2. 如何定义和使用它们

直接赋值即可创建整数和浮点数变量：

```python
# 定义整数
age = 30
year = -2023
big_number = 12345678901234567890 # Python 3 整数没有大小限制

print(f"age 的类型是: {type(age)}")
print(f"year 的类型是: {type(year)}")
print(f"big_number 的类型是: {type(big_number)}")

# 定义浮点数
pi = 3.14159
temperature = -4.5
speed = 3.0 # 即使是整数值，加上小数点就变成了浮点数
scientific = 1.5e-3 # 表示 1.5 * 10^(-3) = 0.0015

print(f"\npi 的类型是: {type(pi)}")
print(f"temperature 的类型是: {type(temperature)}")
print(f"speed 的类型是: {type(speed)}")
print(f"scientific 的类型是: {type(scientific)}")
```

**注意**: `type()` 函数可以帮助你查看任何变量的数据类型。

------

### 3. 基本算术运算

整数和浮点数都支持标准的算术运算符：

| **运算符** | **名称**    | **示例 (int)** | **结果 (int)** | **示例 (float)** | **结果 (float)** |
| ---------- | ----------- | -------------- | -------------- | ---------------- | ---------------- |
| `+`        | 加法        | `5 + 3`        | `8`            | `5.0 + 3.0`      | `8.0`            |
| `-`        | 减法        | `5 - 3`        | `2`            | `5.0 - 3.0`      | `2.0`            |
| `*`        | 乘法        | `5 * 3`        | `15`           | `5.0 * 3.0`      | `15.0`           |
| `/`        | 除法        | `10 / 3`       | `3.333...`     | `10.0 / 3.0`     | `3.333...`       |
| `%`        | 取模 (余数) | `10 % 3`       | `1`            | `10.0 % 3.0`     | `1.0`            |
| `//`       | 整除        | `10 // 3`      | `3`            | `10.0 // 3.0`    | `3.0`            |
| `**`       | 幂运算      | `2 ** 3`       | `8`            | `2.0 ** 3.0`     | `8.0`            |

**重要**:

- 在 Python 3 中，无论操作数是整数还是浮点数，`/` 除法的结果 **总是** 浮点数。
- `//` 整除运算符会丢弃小数部分，结果的类型取决于操作数的类型：如果都是整数，结果是整数；如果至少有一个是浮点数，结果是浮点数（但值是整除后的整数部分）。



```python
# 整数运算
a = 10
b = 3

print(f"\n整数运算:")
print(f"a + b = {a + b}")
print(f"a - b = {a - b}")
print(f"a * b = {a * b}")
print(f"a / b = {a / b} (注意这里是浮点数结果)")
print(f"a % b = {a % b}")
print(f"a // b = {a // b}")
print(f"a ** b = {a ** b}")

# 浮点数运算
c = 10.0
d = 3.0

print(f"\n浮点数运算:")
print(f"c + d = {c + d}")
print(f"c - d = {c - d}")
print(f"c * d = {c * d}")
print(f"c / d = {c / d}")
print(f"c % d = {c % d}")
print(f"c // d = {c // d} (浮点数的整除结果也是浮点数)")
print(f"c ** d = {c ** d}")
```

------

### 4. 类型转换 (Casting)

你可以使用内置函数在整数和浮点数之间进行转换：

- `int(x)`: 将 `x` 转换为整数。如果 `x` 是浮点数，它会 **截断** 小数部分（直接去掉，而不是四舍五入）。如果 `x` 是字符串，它必须是合法的整数表示。
- `float(x)`: 将 `x` 转换为浮点数。如果 `x` 是整数，它会加上 `.0`。如果 `x` 是字符串，它必须是合法的数字表示（整数或浮点数）。



```python
# int 转 float
num_int = 100
num_float = float(num_int)
print(f"\nint 转 float: {num_int} -> {num_float}, type: {type(num_float)}")

# float 转 int (截断)
num_float2 = 123.789
num_int2 = int(num_float2)
print(f"float 转 int (截断): {num_float2} -> {num_int2}, type: {type(num_int2)}")

# float 转 int (另一个例子)
num_float3 = -4.9
num_int3 = int(num_float3)
print(f"float 转 int (截断): {num_float3} -> {num_int3}, type: {type(num_int3)}") # 注意，是向零的方向截断

# 字符串转数字
str_int = "123"
str_float = "45.67"

try:
    int_from_str = int(str_int)
    float_from_str = float(str_float)
    print(f"字符串转 int: \"{str_int}\" -> {int_from_str}, type: {type(int_from_str)}")
    print(f"字符串转 float: \"{str_float}\" -> {float_from_str}, type: {type(float_from_str)}")

    # 尝试转换非数字字符串会导致 ValueError
    # invalid_str = "hello"
    # int(invalid_str) # 这行会报错
except ValueError as e:
    print(f"转换错误: {e}")
```

------

### 5. int 和 float 混合运算

当一个整数和一个浮点数进行运算时，Python 会自动将整数 **提升** 为浮点数，然后再进行计算。结果将是浮点数。

Python

```
result_mixed = 5 + 3.14
print(f"\nint 和 float 混合运算: 5 + 3.14 = {result_mixed}, type: {type(result_mixed)}")

result_mixed2 = 10 * 2.5
print(f"int 和 float 混合运算: 10 * 2.5 = {result_mixed2}, type: {type(result_mixed2)}")

result_mixed3 = 10 / 2 # 即使整除，结果也是 float
print(f"int 和 int / float: 10 / 2 = {result_mixed3}, type: {type(result_mixed3)}")

result_mixed4 = 10 // 3.0 # 整除，但有一个是 float，结果是 float
print(f"int // float: 10 // 3.0 = {result_mixed4}, type: {type(result_mixed4)}")
```

这种自动类型提升是很方便的，但你需要注意最终结果的数据类型。

------

### 6. 浮点数精度问题

这是掌握 `float` 时非常重要的一个概念。由于计算机使用二进制来表示浮点数，而许多十进制小数（如 0.1, 0.2）在二进制下是无限循环的，无法精确表示。这会导致微小的舍入误差。

Python

```
print(f"\n浮点数精度问题:")
print(0.1 + 0.2) # 结果不是精确的 0.3
print(0.1 + 0.2 == 0.3) # 结果是 False

# 另一个例子
print(1 / 3)
print(1 / 3 * 3) # 结果可能不是精确的 1.0
```

**为什么会这样？**

就像十进制无法精确表示 1/3 (0.333...) 一样，许多十进制小数在二进制下也是无限循环的。计算机只能存储有限的位数，所以会进行截断或舍入，从而产生微小的误差。

**什么时候需要注意？**

- 进行 **精确** 的金融计算时。
- 进行比较相等性 (`==`) 时，浮点数的相等性比较通常需要小心，最好比较它们的差是否在一个很小的范围内 (`abs(a - b) < epsilon`)。

**解决方案 (了解即可)**

对于需要高精度计算的场景，可以使用 Python 标准库中的 `decimal` 模块，它可以提供任意精度的十进制浮点运算。但对于大多数科学计算或日常用途，标准的 `float` 已经足够。

------

### 7. 常用内置函数

除了上面提到的 `type()`, `int()`, `float()`，还有一些常用的内置函数用于数字操作：

- `abs(x)`: 返回 `x` 的绝对值。

- `round(x, n=None)`: 对 `x` 进行四舍五入。
- 如果 `n` 被省略，返回最接近的整数（但结果是浮点数，如 `round(3.14)` 返回 `3.0`，`round(3.5)` 返回 `4.0`）。
   - 如果指定 `n`，则四舍五入到小数点后 `n` 位。
- **注意**: Python 3 的 `round()` 函数在处理 `.5` 的情况下，遵循「银行家舍入」（round half to even）的规则，即当小数部分恰好是 0.5 时，会舍入到最近的偶数整数。例如 `round(2.5)` 是 `2.0`，`round(3.5)` 是 `4.0`。

```python
print(f"\n常用内置函数:")
print(f"abs(-10) = {abs(-10)}")
print(f"abs(-5.5) = {abs(-5.5)}")

print(f"round(3.14159) = {round(3.14159)}")
print(f"round(3.14159, 2) = {round(3.14159, 2)}")
print(f"round(3.5) = {round(3.5)}")   # 银行家舍入
print(f"round(2.5) = {round(2.5)}")   # 银行家舍入
print(f"round(4.789, 1) = {round(4.789, 1)}")
```

好的，让我们深入学习 Python 的字符串类型 (`str`)。字符串是 Python 中最常用的数据类型之一，用于表示文本数据。

---

## 字符串( str )

### 1\. 什么是字符串 (str)

字符串是一个由零个或多个字符组成的序列。字符可以是字母、数字、符号、空格等等。在 Python 中，字符串是 **不可变 (immutable)** 的序列。这意味着一旦创建了一个字符串对象，就不能更改它里面的单个字符。任何看起来像修改字符串的操作，实际上都是创建了一个新的字符串对象。

### 2\. 如何创建字符串

可以使用单引号 (`'`)、双引号 (`"`)、三单引号 (`'''`) 或三双引号 (`"""`) 来创建字符串。

  * **单引号或双引号**: 用于创建单行字符串。通常建议在整个项目中统一使用其中一种风格。

    ```python
    string1 = 'Hello, World!'
    string2 = "Python Programming"
    print(type(string1))
    print(type(string2))
    ```

    如果字符串本身包含单引号或双引号，可以使用另一种引号来包围它，或者使用转义字符 (`\`)。

    ```python
    quote1 = "He said, 'Hello!'"
    quote2 = 'It\'s a beautiful day.' # 使用反斜杠转义单引号
    quote3 = "She said, \"Wow!\""  # 使用反斜杠转义双引号
    print(quote1)
    print(quote2)
    print(quote3)
    ```

  * **三单引号或三双引号**: 用于创建多行字符串。它们可以跨越多行，并且会保留原始字符串中的换行符和缩进。

    ```python
    multiline_string = """This is a
    multiline string.
    It preserves
    line breaks and
    indentation."""
    print(multiline_string)
    
    multiline_string2 = '''Another
    multiline
    string.'''
    print(multiline_string2)
    ```

### 3\. 字符串的不可变性

这是字符串的一个重要特性。你不能修改一个已存在的字符串对象中的某个字符。

```python
my_string = "Python"
# my_string [0] = "J" # 这行代码会引发 TypeError 错误，因为字符串不可变

# 如果想改变，必须创建一个新的字符串
new_string = "Jython" # 创建了一个新的字符串对象
print(my_string)
print(new_string)

# 看起来像修改的操作，实际上是重新赋值 (创建新对象)
greeting = "Hello"
greeting = greeting + ", World!" # 创建了一个新的字符串 "Hello, World!"，并让 greeting 变量指向它
print(greeting)
```

### 4\. 访问字符串中的字符 (索引)

字符串中的每个字符都有一个对应的位置编号，称为 **索引 (index)**。索引从 0 开始。你也可以使用负数索引，它从字符串的末尾开始计数，-1 表示最后一个字符，-2 表示倒数第二个字符，以此类推。

```python
word = "Example"
# 索引: E = 0, x = 1, a = 2, m = 3, p = 4, l = 5, e = 6
# 负索引: E =-7, x =-6, a =-5, m =-4, p =-3, l =-2, e =-1

print(f"第一个字符: {word[0]}")
print(f"第三个字符: {word[2]}")
print(f"最后一个字符: {word[-1]}")
print(f"倒数第三个字符: {word[-3]}")

# 尝试访问超出范围的索引会导致 IndexError 错误
# print(word [10])
# print(word [-10])
```

### 5\. 字符串切片 (Slicing)

切片允许你从字符串中提取一部分作为子字符串。语法是 `[start:stop:step]`。

  * `start`: 切片的起始索引（包含此索引处的字符）。如果省略，默认为 0。
  * `stop`: 切片的结束索引（**不包含** 此索引处的字符）。如果省略，默认为字符串的末尾。
  * `step`: 切片的步长（跳跃的间隔）。如果省略，默认为 1。步长可以是负数，用于反向切片。

```python
phrase = "Python Slicing"
# 索引: P = 0, y = 1, t = 2, h = 3, o = 4, n = 5, ' '= 6, S = 7, l = 8, i = 9, c = 10, i = 11, n = 12, g = 13

print(f"\n原始字符串: {phrase}")
print(f"从索引 0 到 6 (不包含 6): {phrase[0:6]}") # Python
print(f"从索引 7 到末尾: {phrase[7:]}")      # Slicing
print(f"从开头到索引 6 (不包含 6): {phrase[:6]}")      # Python
print(f"复制整个字符串: {phrase[:]}")       # Python Slicing
print(f"从索引 0 到末尾，步长为 2: {phrase[::2]}")     # Pto lc n
print(f"反转字符串: {phrase[::-1]}")      # gnicilS nohtyP
print(f"从索引 7 到 12 (不包含 12): {phrase[7:12]}")    # Slici
```

### 6\. 字符串长度

使用内置函数 `len()` 可以获取字符串中字符的数量。

```python
string_length = "Hello"
print(f"\n字符串 '{string_length}' 的长度是: {len(string_length)}")
print(f"空字符串的长度是: {len('')}")
```

### 7\. 字符串拼接和重复

  * **拼接 (`+`)**: 使用 `+` 运算符可以将两个或多个字符串连接起来。
    ```python
    greeting = "Hello"
    name = "Alice"
    message = greeting + ", " + name + "!"
    print(f"\n拼接字符串: {message}")
    ```
  * **重复 (`*`)**: 使用 `*` 运算符和一个整数可以重复字符串多次。
    ```python
    repeat_string = "abc" * 3
    print(f"重复字符串: {repeat_string}")
    ```

### 8\. 字符串方法

字符串对象有很多内置的方法（函数），可以用来执行各种操作，如查找、替换、分割、改变大小写等。调用方法使用点号 (`.`)。记住，大多数字符串方法都会返回一个 **新的** 字符串，而不会修改原字符串。

```python
sample_string = "  Hello Python World  "

print(f"\n常用字符串方法:")
print(f"转为大写: {sample_string.upper()}")
print(f"转为小写: {sample_string.lower()}")
print(f"首字母大写: {sample_string.capitalize()}")
print(f"每个单词首字母大写: {sample_string.title()}")

print(f"查找 'Python' 的起始索引: {sample_string.find('Python')}") # 如果找不到返回 -1
print(f"替换 'World' 为 'Universe': {sample_string.replace('World', 'Universe')}")

# 分割字符串，返回一个列表
words_list = sample_string.split() # 默认按空格分割
print(f"按空格分割: {words_list}")
words_list2 = "apple,banana,cherry".split(',')
print(f"按逗号分割: {words_list2}")

# 连接列表中的字符串，返回一个新字符串
joined_string = "-".join(["a", "b", "c"])
print(f"用 '-' 连接列表: {joined_string}")

print(f"是否以 '  Hello' 开头: {sample_string.startswith('  Hello')}")
print(f"是否以 'World  ' 结尾: {sample_string.endswith('World  ')}")

print(f"移除开头和结尾的空白符: '{sample_string.strip()}'")
print(f"移除开头的空白符: '{sample_string.lstrip()}'")
print(f"移除结尾的空白符: '{sample_string.rstrip()}'")

numeric_string = "12345"
alphabetic_string = "abcdef"
alphanumeric_string = "abc123"
whitespace_string = "   "

print(f"' {numeric_string} ' 是数字组成吗: {numeric_string.isdigit()}")
print(f"' {alphabetic_string} ' 是字母组成吗: {alphabetic_string.isalpha()}")
print(f"' {alphanumeric_string} ' 是字母或数字组成吗: {alphanumeric_string.isalnum()}")
print(f"' {whitespace_string} ' 是空白符组成吗: {whitespace_string.isspace()}")
```

还有很多其他字符串方法，你可以查阅 Python 官方文档来了解更多。

### 9\. 转义序列 (Escape Sequences)

转义序列以反斜杠 (`\`) 开头，用于在字符串中表示特殊字符，这些字符直接输入可能导致问题或有特殊含义。

| 转义序列 | 表示字符     |
| :------- | :----------- |
| `\'`     | 单引号       |
| `\"`     | 双引号       |
| `\\`     | 反斜杠       |
| `\n`     | 换行符       |
| `\t`     | 制表符 (Tab) |
| `\r`     | 回车符       |
| `\b`     | 退格符       |

```python
print(f"\n转义序列:")
print("This is a line.\nThis is another line.")
print("Item 1:\tValue 1")
print("Item 2:\tValue 2")
print("This contains a backslash: \\")
print("She said, \"Hello!\"")
```

### 10\. 原始字符串 (Raw Strings)

在某些情况下，你可能不想让反斜杠作为转义符，而是希望它被当作普通字符处理，特别是在处理文件路径或正则表达式时。这时可以在字符串前加上 `r` 或 `R`，创建原始字符串。

```python
print(f"\n原始字符串:")
# 普通字符串，\n 会被解释为换行
print("C:\\Users\\name\\documents\\newfolder")

# 原始字符串，\n 不会被解释
print(r"C:\Users\name\documents\newfolder")

# 正则表达式中常用
import re
pattern = r"\d+\.\d+" # 匹配一个或多个数字，后跟一个点，后跟一个或多个数字
text = "The value is 3.14"
match = re.search(pattern, text)
print(f"使用原始字符串的正则表达式匹配: {match.group() if match else 'No match'}")
```

**注意**: 原始字符串不能以单个反斜杠结束。`r"abc\"` 是非法的，但 `r"abc\\"` 或 `r"abc"` 是合法的。

### 11\. 字符串格式化

将变量或其他值插入到字符串中有多种方法。

  * **F-strings (Formatted String Literals) - 推荐**: 在字符串前加上 `f` 或 `F`，然后在字符串中使用大括号 `{}` 包围变量名或表达式。这是 Python 3.6+ 中最简洁和推荐的方式。

    ```python
    name = "Alice"
    age = 30
    print(f"\nF-strings 格式化:")
    print(f"My name is {name} and I am {age} years old.")
    print(f"The result of 2 * 3 is {2 * 3}.")
    ```

  * **`.format()` 方法**: 这是在 f-strings 之前常用的方法。使用 `{}` 作为占位符，然后调用字符串的 `.format()` 方法，传入要填充的值。

    ```python
    print(f"\n.format() 方法格式化:")
    print("My name is {} and I am {} years old.".format(name, age))
    print("My name is {0} and I am {1} years old.".format(name, age)) # 可以通过索引指定位置
    print("My name is {n} and I am {a} years old.".format(n=name, a=age)) # 可以通过关键字指定
    ```

  * **百分号 (%) 格式化 (旧式)**: 类似于 C 语言的 printf 风格，使用 `%` 作为占位符。在现代 Python 中较少使用，但在维护旧代码时可能会看到。

    ```python
    # print(f "\n 百分号 (%) 格式化 (旧式):")
    # print("My name is %s and I am %d years old." % (name, age)) # %s for string, %d for integer
    ```

-----

## 布尔类型（bool）

Python 的布尔类型（bool）是一种基本数据类型，只有两个可能的值：

- `True`（真）
  
- `False`（假）
  

```python
# 基本布尔值

is_student = True  
has_graduated = False  

print(type(True))   # <class 'bool'>  
print(type(False))  # <class 'bool'>
```

**重要注意事项：**

- `True` 和 `False` 必须首字母大写
  
- 它们是 Python 的关键字，不需要引号
  
- `true` 和 `false`（小写）会导致 NameError
  

### 类型特性

#### bool 是 int 的子类

```python
 print(issubclass(bool, int))  # True  
 print(isinstance(True, int))  # True  


 # 布尔值的数值特性  
 print(True == 1)    # True  
 print(False == 0)   # True  
 print(True + True)  # 2  
 print(False * 10)   # 0
```

#### 为什么 bool 继承自 int？

1. **历史兼容性**：确保现有代码继续工作
   
2. **实现简便性**：简化了 C 级别的实现
   
3. **数学运算**：允许布尔值参与算术运算
   

### bool()函数

`bool()` 函数可以将任何 Python 对象转换为布尔值：

```python
 # 数值类型  
 print(bool(0))      # False  
 print(bool(1))      # True  
 print(bool(-5))     # True  
 print(bool(0.0))    # False  
 print(bool(3.14))   # True  
   
 # 字符串类型  
 print(bool(""))     # False (空字符串)  
 print(bool("0"))    # True (非空字符串)  
 print(bool("hello")) # True  
   
 # 容器类型  
 print(bool([]))     # False (空列表)  
 print(bool([1,2]))  # True (非空列表)  
 print(bool({}))     # False (空字典)  
 print(bool({"a": 1})) # True (非空字典)  
   
 # 特殊值  
 print(bool(None))   # False
```

### 布尔运算符

#### 逻辑运算符

- `and`：逻辑与
  
- `or`：逻辑或
  
- `not`：逻辑非

```python
 # and 运算符  
 print(True and True)   # True  
 print(True and False)  # False  
 print(False and True)  # False  
 print(False and False) # False  
   
 # or 运算符  
 print(True or True)    # True  
 print(True or False)   # True  
 print(False or True)   # True  
 print(False or False)  # False  
   
 # not 运算符  
 print(not True)        # False  
 print(not False)       # True
```
#### 短路求值

Python 的逻辑运算符使用短路求值：
```python
 def expensive_function():  
     print("函数被调用了")  
     return True  
   
 # and 短路：如果第一个操作数为 False，不会计算第二个  
 result1 = False and expensive_function()  # 函数不会被调用  
   
 # or 短路：如果第一个操作数为 True，不会计算第二个  
 result2 = True or expensive_function()    # 函数不会被调用
```

#### 运算符优先级

优先级从高到低：`not` > `and` > `or`

```python
 print(True or False and False)    # True (等价于 True or (False and False))  
 print((True or False) and False)  # False
```

### 真值和假值

在 Python 中，所有对象都可以在布尔上下文中测试真假：

#### 假值（Falsy Values）

以下值被认为是假值：

- `False`
  
- `None`
  
- 数值零：`0`, `0.0`, `0j`
  
- 空序列：`''`, `[]`, `()`
  
- 空映射：`{}`
  
- 空集合：`set()`
  
- 自定义对象的 `__bool__()` 返回 `False` 或 `__len__()` 返回 `0`
  

#### 真值（Truthy Values）

除了假值之外的所有值都是真值：

- `True`
  
- 非零数值
  
- 非空字符串
  
- 非空容器
  
- 大部分自定义对象
  

### 自定义类的布尔行为

#### 使用 **bool** 方法

```python
 class BankAccount:  
     def __init__(self, balance):  
         self.balance = balance  
       
     def __bool__(self):  
         return self.balance > 0  
   
 account1 = BankAccount(100)  # 有余额  
 account2 = BankAccount(0)    # 无余额  
   
 print(bool(account1))  # True  
 print(bool(account2))  # False  
   
 if account1:  
     print("账户有余额")

#### 使用 **len** 方法

如果没有定义 `__bool__` 方法，Python 会使用 `__len__` 方法：

 class Playlist:  
     def __init__(self):  
         self.songs = []  
       
     def add_song(self, song):  
         self.songs.append(song)  
       
     def __len__(self):  
         return len(self.songs)  
  
 playlist = Playlist()  
 print(bool(playlist))  # False (长度为 0)  
   
 playlist.add_song("Song 1")  
 print(bool(playlist))  # True (长度大于 0)
```
### 实际应用场景

#### 1. 条件控制

```python
 def check_access(user, resource):  
     has_permission = user.is_admin or user.owns(resource)  
     is_active = user.is_active and not user.is_banned  
       
     return has_permission and is_active
```
#### 2. 数据验证
```python
 def validate_form(username, password, email):  
     return (bool(username) and len(username) >= 3 and  
             bool(password) and len(password) >= 8 and  
             bool(email) and '@' in email)
```
#### 3. 安全的操作（防护模式）
```python
 def safe_divide(a, b):  
     "" "使用短路求值避免除零错误" ""  
     return b != 0 and a / b  
   
 def safe_access(data, index):  
     "" "安全访问列表元素" ""  
     return 0 <= index < len(data) and data [index]
```
#### 4. 过滤和筛选
```python
 # 过滤真值  
 valid_data = [item for item in data if item]  
 
 # 过滤满足条件的项  
 adults = [person for person in people if person.age >= 18]
```

### 最佳实践

#### 1. 利用 Python 的真值测试

```python
 # ❌ 不推荐  
 if len(my_list) > 0:  
     process(my_list)  
 
 if my_string != "":  
     process(my_string)  
 
 # ✅ 推荐  
 if my_list:  
     process(my_list)  
  
 if my_string:  
     process(my_string)
```
#### 2. 避免冗余的布尔表达式
```python
 # ❌ 不推荐  
 def is_adult(age):  
     if age >= 18:  
         return True  
     else:  
         return False  

 # ✅ 推荐  
 def is_adult(age):  
     return age >= 18
```
#### 3. 布尔变量命名

使用有意义的前缀：
```python
# ✅ 好的命名  
is_active = True  
has_permission = False  
can_edit = True  
should_retry = False
```
#### 4. 使用短路求值
```python
 # ✅ 安全的做法  
 if user and user.is_authenticated():  
     grant_access()  
  
 if items and process_items(items):  
     show_success()
```
### 常见错误

#### 1. 直接与 True/False 比较
```python
 # ❌ 错误  
 if flag == True:  
     do_something()  

 # ✅ 正确  
 if flag:  
     do_something()
```
#### 2. 错误的多值比较
```python
 # ❌ 错误  
 if x == 1 or 2 or 3:  # 总是 True  
     do_something()  
 # ✅ 正确  
 if x in [1, 2, 3]:  
     do_something()  
 # 或者  
 if x == 1 or x == 2 or x == 3:  
     do_something()
```
#### 3. 混淆 is 和 ==
```python
 # ❌ 对于布尔值，这样做有风险  
 if flag is True:  
     do_something()  
     
 # ✅ 正确的比较  
 if flag == True:  # 或者更好的是 if flag:  
     do_something()
```

当然！下面是一份关于如何在 Python 中进行不同数据类型之间转换的教程。

## 数据类型转换

Python 是一种动态类型语言，但理解和掌握不同数据类型之间的转换对于编写健壮和灵活的代码至关重要。

### 1. 为什么需要数据类型转换？

* **数据兼容性：** 不同操作可能需要特定类型的数据。例如，你不能直接将字符串 "10" 和整数 5 相加。
* **数据清洗：** 从外部源（如文件、网络请求）获取的数据通常是字符串形式，需要转换为其他类型才能进行计算或处理。
* **用户输入：** `input()` 函数总是返回字符串，如果需要数字或其他类型的数据，则必须进行转换。
* **格式化输出：** 有时需要将数字转换为字符串以便于打印或与其他字符串拼接。

### 2. 常用数据类型转换函数

Python 内置了许多函数用于数据类型转换。以下是一些最常用的：

#### 2.1 转换为整数 (`int()`)

`int()` 函数可以将其他类型（主要是数字型字符串或浮点数）转换为整数。

**语法:** `int(x, base=10)`

* `x`: 要转换的值。
* `base`: 可选参数，表示字符串 `x` 的进制（默认为 10 进制）。

**示例:**

```python
# 浮点数转换为整数（截断小数部分）
float_num = 3.14
int_from_float = int(float_num)
print(f"浮点数 {float_num} 转换为整数: {int_from_float}") # 输出: 3

# 数字字符串转换为整数
str_num = "123"
int_from_str = int(str_num)
print(f"字符串 '{str_num}' 转换为整数: {int_from_str}") # 输出: 123

# 带进制的字符串转换为整数
binary_str = "1011"
int_from_binary = int(binary_str, 2)
print(f"二进制字符串 '{binary_str}' 转换为整数: {int_from_binary}") # 输出: 11

hex_str = "A5"
int_from_hex = int(hex_str, 16)
print(f"十六进制字符串 '{hex_str}' 转换为整数: {int_from_hex}") # 输出: 165

# 注意：如果字符串不是有效的数字或包含非数字字符，则会引发 ValueError
# invalid_str = "hello"
# int_from_invalid = int(invalid_str) # 这会报错
```

#### 2.2 转换为浮点数 (`float()`)

`float()` 函数可以将整数或数字型字符串转换为浮点数。

**语法:** `float(x)`

* `x`: 要转换的值。

**示例:**

```python
# 整数转换为浮点数
int_num = 10
float_from_int = float(int_num)
print(f"整数 {int_num} 转换为浮点数: {float_from_int}") # 输出: 10.0

# 数字字符串转换为浮点数
str_float = "3.14159"
float_from_str = float(str_float)
print(f"字符串 '{str_float}' 转换为浮点数: {float_from_str}") # 输出: 3.14159

# 注意：如果字符串不是有效的浮点数表示，则会引发 ValueError
# invalid_float_str = "abc"
# float_from_invalid = float(invalid_float_str) # 这会报错
```

#### 2.3 转换为字符串 (`str()`)

`str()` 函数可以将几乎所有类型的数据转换为字符串。

**语法:** `str(x)`

* `x`: 要转换的值。

**示例:**

```python
# 整数转换为字符串
num = 123
str_from_int = str(num)
print(f"整数 {num} 转换为字符串: '{str_from_int}' (类型: {type(str_from_int)})") # 输出: '123' (类型: <class 'str'>)

# 浮点数转换为字符串
pi = 3.14159
str_from_float = str(pi)
print(f"浮点数 {pi} 转换为字符串: '{str_from_float}'") # 输出: '3.14159'

# 列表转换为字符串
my_list = [1, 2, 3]
str_from_list = str(my_list)
print(f"列表 {my_list} 转换为字符串: '{str_from_list}'") # 输出: '[1, 2, 3]'

# 布尔值转换为字符串
is_true = True
str_from_bool = str(is_true)
print(f"布尔值 {is_true} 转换为字符串: '{str_from_bool}'") # 输出: 'True'
```

#### 2.4 转换为布尔值 (`bool()`)

`bool()` 函数可以将任何类型的数据转换为布尔值。

**语法:** `bool(x)`

* `x`: 要转换的值。

**“假”值规则：**
在 Python 中，以下值会被认为是 `False`：

* `None`
* `False`
* 数字 `0` (整数、浮点数、复数)
* 空序列 (空字符串 `""`, 空列表 `[]`, 空元组 `()`)
* 空映射 (空字典 `{}` )
* 空集合 (`set()`)

所有其他值都被认为是 `True`。

**示例:**

```python
# 整数转换为布尔值
print(f"bool(0): {bool(0)}")     # 输出: False
print(f"bool(1): {bool(1)}")     # 输出: True
print(f"bool(-5): {bool(-5)}")   # 输出: True

# 浮点数转换为布尔值
print(f"bool(0.0): {bool(0.0)}") # 输出: False
print(f"bool(3.14): {bool(3.14)}")# 输出: True

# 字符串转换为布尔值
print(f"bool(''): {bool('')}")   # 输出: False
print(f"bool('hello'): {bool('hello')}") # 输出: True
print(f"bool('False'): {bool('False')}") # 注意：非空字符串 'False' 也是 True

# 列表、元组、字典、集合转换为布尔值
print(f"bool([]): {bool([])}")   # 输出: False
print(f"bool([1, 2]): {bool([1, 2])}") # 输出: True
print(f"bool(()): {bool(())}")   # 输出: False
print(f"bool({{}}): {bool({{}})}") # 输出: False
print(f"bool(set()): {bool(set())}") # 输出: False

# None 转换为布尔值
print(f"bool(None): {bool(None)}") # 输出: False
```

#### 2.5 转换为列表 (`list()`)

`list()` 函数可以将可迭代对象（如字符串、元组、集合、字典的键）转换为列表。

**语法:** `list(iterable)`

* `iterable`: 任何可迭代对象。

**示例:**

```python
# 字符串转换为列表
my_string = "Python"
list_from_str = list(my_string)
print(f"字符串 '{my_string}' 转换为列表: {list_from_str}") # 输出: ['P', 'y', 't', 'h', 'o', 'n']

# 元组转换为列表
my_tuple = (1, 2, 3)
list_from_tuple = list(my_tuple)
print(f"元组 {my_tuple} 转换为列表: {list_from_tuple}") # 输出: [1, 2, 3]

# 集合转换为列表（顺序不保证）
my_set = {1, 2, 3, 1}
list_from_set = list(my_set)
print(f"集合 {my_set} 转换为列表: {list_from_set}") # 输出: [1, 2, 3] (顺序可能不同)

# 字典的键转换为列表
my_dict = {'a': 1, 'b': 2}
list_from_dict_keys = list(my_dict)
print(f"字典 {my_dict} 的键转换为列表: {list_from_dict_keys}") # 输出: ['a', 'b']
```

#### 2.6 转换为元组 (`tuple()`)

`tuple()` 函数与 `list()` 类似，可以将可迭代对象转换为元组。

**语法:** `tuple(iterable)`

* `iterable`: 任何可迭代对象。

**示例:**

```python
# 字符串转换为元组
my_string = "Hello"
tuple_from_str = tuple(my_string)
print(f"字符串 '{my_string}' 转换为元组: {tuple_from_str}") # 输出: ('H', 'e', 'l', 'l', 'o')

# 列表转换为元组
my_list = [4, 5, 6]
tuple_from_list = tuple(my_list)
print(f"列表 {my_list} 转换为元组: {tuple_from_list}") # 输出: (4, 5, 6)

# 集合转换为元组
my_set = {4, 5, 6}
tuple_from_set = tuple(my_set)
print(f"集合 {my_set} 转换为元组: {tuple_from_set}") # 输出: (4, 5, 6) (顺序可能不同)
```

#### 2.7 转换为集合 (`set()`)

`set()` 函数可以将可迭代对象转换为集合。集合的一个主要特性是存储唯一的元素，重复的元素会被自动移除。

**语法:** `set(iterable)`

* `iterable`: 任何可迭代对象。

**示例:**

```python
# 列表转换为集合（去除重复项）
my_list = [1, 2, 2, 3, 4, 4, 5]
set_from_list = set(my_list)
print(f"列表 {my_list} 转换为集合: {set_from_list}") # 输出: {1, 2, 3, 4, 5}

# 字符串转换为集合（每个字符都是一个元素，去除重复字符）
my_string = "banana"
set_from_str = set(my_string)
print(f"字符串 '{my_string}' 转换为集合: {set_from_str}") # 输出: {'b', 'a', 'n'} (顺序不保证)
```

#### 2.8 转换为字典 (`dict()`)

`dict()` 函数可以将一系列键值对转换为字典。它接受以下形式的参数：

* **1. 键值对元组的列表/元组:** `[('key1', value1), ('key2', value2)]`
* **2. 关键字参数:** `dict(key1=value1, key2=value2)`

**示例:**

```python
# 从键值对元组的列表创建字典
list_of_tuples = [('name', 'Alice'), ('age', 30)]
dict_from_list = dict(list_of_tuples)
print(f"从列表创建字典: {dict_from_list}") # 输出: {'name': 'Alice', 'age': 30}

# 从关键字参数创建字典
dict_from_keywords = dict(city='New York', population=8000000)
print(f"从关键字参数创建字典: {dict_from_keywords}") # 输出: {'city': 'New York', 'population': 8000000}

# 注意：如果输入格式不正确，会引发 TypeError 或 ValueError
# invalid_input = [1, 2, 3]
# dict_from_invalid = dict(invalid_input) # 这会报错
```

### 3. 类型转换的注意事项

* **数据丢失：**
    * `int(float_num)` 会截断小数部分，而不是四舍五入。
    * 将数字转换为字符串时，精度不会丢失，但再转换回数字时可能会因为浮点数精度问题略有差异。
* **`ValueError`：**
    * 当你尝试将一个不能转换为目标类型的字符串（例如，将 "hello" 转换为 `int`）时，会引发 `ValueError`。
    * 在进行字符串到数字的转换时，最好使用 `try-except` 块来处理潜在的 `ValueError`。
* **`TypeError`：**
    * 当你尝试将一个不支持转换操作的类型作为参数传递给转换函数时，会引发 `TypeError`。例如，`int([1,2])` 会报错。
* **集合和字典的无序性：** 转换为 `set` 或 `dict` 后，元素的顺序可能不会保留。

### 4. 实践案例

假设我们从用户那里获取输入，并需要进行一些数学计算。

```python
# 获取用户输入
user_input_str_1 = input("请输入第一个数字: ")
user_input_str_2 = input("请输入第二个数字: ")

try:
    # 尝试将字符串转换为浮点数
    num1 = float(user_input_str_1)
    num2 = float(user_input_str_2)

    # 进行计算
    sum_nums = num1 + num2
    product_nums = num1 * num2

    # 将结果转换为字符串进行输出
    print(f"这两个数字的和是: {str(sum_nums)}")
    print(f"这两个数字的积是: {str(product_nums)}")

except ValueError:
    print("错误：请输入有效的数字。")
except Exception as e:
    print(f"发生未知错误: {e}")

# 示例：将列表中的数字转换为字符串
numbers = [10, 20, 30]
str_numbers = [str(num) for num in numbers] # 使用列表推导式
print(f"数字列表转换为字符串列表: {str_numbers}") # 输出: ['10', '20', '30']

# 示例：将字符串中的数字提取并求和
data_str = "items: 10, cost: 25.5, quantity: 3"
import re # 导入正则表达式模块

# 使用正则表达式找到所有数字
nums_in_str = re.findall(r'\d+\.?\d*', data_str)
print(f"从字符串中找到的数字（字符串形式）: {nums_in_str}")

total_sum = 0
for s_num in nums_in_str:
    try:
        total_sum += float(s_num)
    except ValueError:
        # 如果不是有效的数字，则跳过
        pass
print(f"提取数字并求和: {total_sum}") # 输出: 38.5
```

好的，这是一份帮助你掌握 Python 算术运算符的教程。

## 算术运算符

在编程中，算术运算符用于执行数学运算，例如加法、减法、乘法等。Python 提供了一套直观且强大的算术运算符，让我们能够轻松地处理数字。掌握这些运算符是学习任何编程语言的基础。

本教程将详细介绍 Python 中的七个主要算术运算符：`+` (加法), `-` (减法), `*` (乘法), `/` (除法), `//` (整除), `%` (取模/取余), `**` (幂运算)。

### 1. 什么是算术运算符？

算术运算符是用于对数值（数字）进行数学计算的符号。它们接受一个或多个操作数（要进行运算的数字）并返回一个结果。

### 2. Python 中的算术运算符

让我们逐一深入了解这些运算符。

#### 2.1 加法运算符 (`+`)

加法运算符用于计算两个或多个数字的和。

**示例：**

```python
a = 10
b = 5

result = a + b
print(f"{a} + {b} = {result}") # 输出: 10 + 5 = 15

# 也可以用于连接字符串（这是一种特殊的用法，不是严格意义上的算术运算）
str1 = "Hello"
str2 = " World"
combined_str = str1 + str2
print(f"'{str1}' + '{str2}' = '{combined_str}'") # 输出: 'Hello' + ' World' = 'Hello World'
```

#### 2.2 减法运算符 (`-`)

减法运算符用于计算两个数字的差。

**示例：**

```python
a = 15
b = 7

result = a - b
print(f"{a} - {b} = {result}") # 输出: 15 - 7 = 8

# 也可以表示负数
negative_num = -10
print(f"负数: {negative_num}") # 输出: 负数: -10
```

#### 2.3 乘法运算符 (`*`)

乘法运算符用于计算两个数字的积。

**示例：**

```python
a = 6
b = 4

result = a * b
print(f"{a} * {b} = {result}") # 输出: 6 * 4 = 24

# 也可以用于字符串的重复
text = "Python"
repeated_text = text * 3
print(f"'{text}' * 3 = '{repeated_text}'") # 输出: 'Python' * 3 = 'PythonPythonPython'
```

#### 2.4 除法运算符 (`/`)

除法运算符用于计算两个数字的商。**需要注意的是，Python 3 中的 `/` 运算符执行的是浮点除法，即使操作数是整数，结果也会是浮点数。**

**示例：**

```python
a = 10
b = 3

result = a / b
print(f"{a} / {b} = {result}") # 输出: 10 / 3 = 3.3333333333333335
print(f"结果的类型: {type(result)}") # 输出: 结果的类型: <class 'float'>

c = 8
d = 2
result_exact = c / d
print(f"{c} / {d} = {result_exact}") # 输出: 8 / 2 = 4.0
print(f"结果的类型: {type(result_exact)}") # 输出: 结果的类型: <class 'float'>
```

#### 2.5 整除运算符 (`//`)

整除运算符（也称为“地板除”）用于计算两个数字的商，并向下取整到最接近的整数。这意味着它会丢弃小数部分，并返回一个整数。

**示例：**

```python
a = 10
b = 3

result = a // b
print(f"{a} // {b} = {result}") # 输出: 10 // 3 = 3

c = 7
d = 2
result_exact_int = c // d
print(f"{c} // {d} = {result_exact_int}") # 输出: 7 // 2 = 3

# 对于负数，结果会向下取整到负无穷大
e = -10
f = 3
result_neg = e // f
print(f"{e} // {f} = {result_neg}") # 输出: -10 // 3 = -4 (而不是 -3)

g = 10
h = -3
result_neg_divisor = g // h
print(f"{g} // {h} = {result_neg_divisor}") # 输出: 10 // -3 = -4
```
**注意：** 当操作数中包含负数时，`//` 运算符的行为是“向下取整到负无穷大”。这意味着结果将是小于或等于精确商的最大整数。例如，-10 / 3 的精确结果约为 -3.33，向下取整后是 -4。

#### 2.6 取模/取余运算符 (`%`)

取模运算符用于计算两个数字相除后的余数。

**示例：**

```python
a = 10
b = 3

result = a % b
print(f"{a} % {b} = {result}") # 输出: 10 % 3 = 1 (10 除以 3 等于 3 余 1)

c = 15
d = 5
result_zero_remainder = c % d
print(f"{c} % {d} = {result_zero_remainder}") # 输出: 15 % 5 = 0

# 对于负数操作数，取模运算的结果符号与除数相同
e = -10
f = 3
result_neg_dividend = e % f
print(f"{e} % {f} = {result_neg_dividend}") # 输出: -10 % 3 = 2 (因为 -10 = 3 * (-4) + 2)

g = 10
h = -3
result_neg_divisor = g % h
print(f"{g} % {h} = {result_neg_divisor}") # 输出: 10 % -3 = -2 (因为 10 = (-3) * (-4) - 2)
```

#### 2.7 幂运算符 (`**`)

幂运算符用于计算一个数字的指定次幂（次方）。

**示例：**

```python
base = 2
exponent = 3

result = base ** exponent
print(f"{base} ** {exponent} = {result}") # 输出: 2 ** 3 = 8 (即 2 * 2 * 2)

# 浮点数幂
float_base = 2.5
float_exponent = 2
result_float_power = float_base ** float_exponent
print(f"{float_base} ** {float_exponent} = {result_float_power}") # 输出: 2.5 ** 2 = 6.25

# 小数幂（开方）
square_root = 16 ** 0.5
print(f"16 ** 0.5 = {square_root}") # 输出: 16 ** 0.5 = 4.0
```

### 3. 运算符优先级

当一个表达式中包含多个算术运算符时，Python 会遵循特定的运算顺序，这被称为“运算符优先级”。这与我们在数学中学到的优先级规则相同：

1.  **括号 `()`**：总是最高优先级，括号内的表达式最先计算。
2.  **幂运算 `**`**：次高优先级。
3.  **乘法 `*`，除法 `/`，整除 `//`，取模 `%`**：这些运算符优先级相同，从左到右依次计算。
4.  **加法 `+`，减法 `-`**：最低优先级，从左到右依次计算。

**助记符：** PEMDAS / BODMAS (括号，指数，乘除，加减)

**示例：**

```python
result1 = 5 + 3 * 2  # 3 * 2 先计算，然后加 5
print(f"5 + 3 * 2 = {result1}") # 输出: 11

result2 = (5 + 3) * 2 # 括号内的 5 + 3 先计算，然后乘以 2
print(f"(5 + 3) * 2 = {result2}") # 输出: 16

result3 = 2 ** 3 + 4 / 2 # 2 ** 3 先计算 (8)，然后 4 / 2 (2.0)，最后 8 + 2.0
print(f"2 ** 3 + 4 / 2 = {result3}") # 输出: 10.0

result4 = 10 / 3 // 2 # 10 / 3 = 3.33...，然后 3.33... // 2 = 1.0
print(f"10 / 3 // 2 = {result4}") # 输出: 1.0
```

好的，这是一份关于 Python 比较运算符的教程。

## 比较运算符

在编程中，除了进行数学运算外，我们经常需要比较两个值的大小、相等性或不相等性。这就需要用到比较运算符。比较运算符在 Python 中用于评估两个值之间的关系，并总是返回一个布尔值（`True` 或 `False`）。它们是控制程序流程（如 `if` 语句和循环）的基础。

### 1. 什么是比较运算符？

比较运算符用于比较两个值。根据比较的结果，它们会返回 `True`（如果条件为真）或 `False`（如果条件为假）。

### 2. Python 中的比较运算符

让我们逐一深入了解这些运算符。

#### 2.1 等于运算符 (`==`)

等于运算符用于检查两个值是否相等。

**示例：**

```python
a = 10
b = 10
c = 5

print(f"{a} == {b} 结果: {a == b}") # 输出: 10 == 10 结果: True
print(f"{a} == {c} 结果: {a == c}") # 输出: 10 == 5 结果: False

# 比较字符串
str1 = "Hello"
str2 = "Hello"
str3 = "hello"

print(f"'{str1}' == '{str2}' 结果: {str1 == str2}") # 输出: 'Hello' == 'Hello' 结果: True
print(f"'{str1}' == '{str3}' 结果: {str1 == str3}") # 输出: 'Hello' == 'hello' 结果: False (大小写敏感)

# 比较不同类型（通常返回 False，除非有明确的转换规则）
print(f"10 == 10.0 结果: {10 == 10.0}") # 输出: 10 == 10.0 结果: True (Python 会进行隐式类型转换来比较数值)
print(f"10 == '10' 结果: {10 == '10'}") # 输出: 10 == '10' 结果: False (不同类型通常不相等)
```

#### 2.2 不等于运算符 (`!=`)

不等于运算符用于检查两个值是否不相等。

**示例：**

```python
a = 10
b = 10
c = 5

print(f"{a} != {b} 结果: {a != b}") # 输出: 10 != 10 结果: False
print(f"{a} != {c} 结果: {a != c}") # 输出: 10 != 5 结果: True

# 比较字符串
str1 = "Apple"
str2 = "Orange"

print(f"'{str1}' != '{str2}' 结果: {str1 != str2}") # 输出: 'Apple' != 'Orange' 结果: True
```

#### 2.3 大于运算符 (`>`)

大于运算符用于检查左侧的值是否大于右侧的值。

**示例：**

```python
a = 20
b = 15
c = 20

print(f"{a} > {b} 结果: {a > b}") # 输出: 20 > 15 结果: True
print(f"{a} > {c} 结果: {a > c}") # 输出: 20 > 20 结果: False
print(f"{b} > {a} 结果: {b > a}") # 输出: 15 > 20 结果: False
```

#### 2.4 小于运算符 (`<`)

小于运算符用于检查左侧的值是否小于右侧的值。

**示例：**

```python
a = 10
b = 15
c = 10

print(f"{a} < {b} 结果: {a < b}") # 输出: 10 < 15 结果: True
print(f"{a} < {c} 结果: {a < c}") # 输出: 10 < 10 结果: False
print(f"{b} < {a} 结果: {b < a}") # 输出: 15 < 10 结果: False
```

#### 2.5 大于等于运算符 (`>=`)

大于等于运算符用于检查左侧的值是否大于或等于右侧的值。

**示例：**

```python
a = 20
b = 15
c = 20

print(f"{a} >= {b} 结果: {a >= b}") # 输出: 20 >= 15 结果: True
print(f"{a} >= {c} 结果: {a >= c}") # 输出: 20 >= 20 结果: True
print(f"{b} >= {a} 结果: {b >= a}") # 输出: 15 >= 20 结果: False
```

#### 2.6 小于等于运算符 (`<=`)

小于等于运算符用于检查左侧的值是否小于或等于右侧的值。

**示例：**

```python
a = 10
b = 15
c = 10

print(f"{a} <= {b} 结果: {a <= b}") # 输出: 10 <= 15 结果: True
print(f"{a} <= {c} 结果: {a <= c}") # 输出: 10 <= 10 结果: True
print(f"{b} <= {a} 结果: {b <= a}") # 输出: 15 <= 10 结果: False
```

### 3. 比较字符串和序列

比较运算符不仅适用于数字，也适用于字符串和其他序列类型（如列表、元组）。

* **字符串比较：** 字符串是根据它们的字典顺序（字母顺序）进行比较的，比较是逐个字符进行的，基于每个字符的 Unicode 值。大小写敏感。
* **序列比较：** 列表、元组等序列也是按元素从左到右依次比较。如果第一个不相等的元素决定了大小关系，则比较停止。如果所有元素都相等且长度相同，则序列相等。如果一个序列是另一个序列的初始子序列，则较短的序列被认为是“小于”较长的序列。

**示例：**

```python
# 字符串比较
print(f"'apple' < 'banana' 结果: {'apple' < 'banana'}") # 输出: True (a 在 b 之前)
print(f"'Apple' < 'apple' 结果: {'Apple' < 'apple'}") # 输出: True (A 的 Unicode 值小于 a)
print(f"'cat' == 'Cat' 结果: {'cat' == 'Cat'}") # 输出: False

# 列表比较
list1 = [1, 2, 3]
list2 = [1, 2, 4]
list3 = [1, 2, 3]
list4 = [1, 2]

print(f"{list1} < {list2} 结果: {list1 < list2}")   # 输出: True (3 < 4)
print(f"{list1} == {list3} 结果: {list1 == list3}") # 输出: True
print(f"{list1} > {list4} 结果: {list1 > list4}")   # 输出: True (list1 较长，且是 list4 的超序列)
```

### 4. 链式比较

Python 支持链式比较，这使得编写复合条件变得非常简洁和易读。

**语法:** `a < b < c` 等同于 `a < b and b < c`

**示例：**

```python
age = 25

# 检查 age 是否在 18 到 30 之间（包含 18 和 30）
is_adult = 18 <= age <= 30
print(f"age {age} 是否在 18 到 30 之间: {is_adult}") # 输出: True

grade = 85
# 检查 grade 是否在 60 到 90 之间（不包含 90）
is_passing_grade = 60 <= grade < 90
print(f"grade {grade} 是否是及格分数: {is_passing_grade}") # 输出: True
```

### 5. 比较运算符在条件语句中的应用

比较运算符最常见的用途是在条件语句（如 `if`, `elif`, `else`）和循环 (`while`) 中，它们决定了程序执行的路径。

**示例：**

```python
score = 75

if score >= 90:
    print("优秀！")
elif score >= 60:
    print("及格。")
else:
    print("不及格。")

# 输出: 及格。

temperature = 28

if temperature > 30:
    print("天气很热！")
elif temperature < 10:
    print("天气很冷！")
else:
    print("天气宜人。")

# 输出: 天气宜人。
```
好的，这是一份帮助你掌握 Python 逻辑运算符的教程。

## 逻辑运算符

在编程中，我们经常需要组合多个条件来做出更复杂的决策。这时，逻辑运算符就派上用场了。逻辑运算符用于连接和评估布尔表达式（即返回 `True` 或 `False` 的表达式），并返回一个最终的布尔结果。它们是控制程序流程，尤其是在 `if` 语句和循环中不可或缺的工具。

### 1. 什么是逻辑运算符？

逻辑运算符是用于结合或修改布尔表达式的特殊关键字。它们通过判断操作数的真假来决定整个表达式的真假。在 Python 中，任何非零数字、非空序列或对象都被视为 `True`，而零、空序列（如空字符串、空列表）和 `None` 被视为 `False`（这被称为“真值判断”）。

### 2. Python 中的逻辑运算符

让我们逐一深入了解这些运算符。

#### 2.1 逻辑与运算符 (`and`)

`and` 运算符用于连接两个或多个布尔表达式。只有当所有连接的表达式都为 `True` 时，整个表达式的结果才为 `True`；否则，结果为 `False`。

**真值表：**

| 表达式 1 | 表达式 2 | 结果 (表达式 1 `and` 表达式 2) |
| -------- | -------- | ------------------------------ |
| `True`   | `True`   | `True`                         |
| `True`   | `False`  | `False`                        |
| `False`  | `True`   | `False`                        |
| `False`  | `False`  | `False`                        |

**示例：**

```python
age = 25
has_license = True

# 条件：年龄大于 18 岁 且 有驾照
can_drive = (age > 18) and has_license
print(f"({age} > 18) and {has_license} = {can_drive}") # 输出: (25 > 18) and True = True

age = 16
can_drive_again = (age > 18) and has_license
print(f"({age} > 18) and {has_license} = {can_drive_again}") # 输出: (16 > 18) and True = False

temperature = 28
is_sunny = True

# 条件：温度在 25 到 30 之间 且 天气晴朗
is_perfect_day = (temperature >= 25 and temperature <= 30) and is_sunny
print(f"((25 <= {temperature} <= 30) and {is_sunny}) = {is_perfect_day}") # 输出: ((25 <= 28 <= 30) and True) = True
```

**短路评估 (Short-circuiting) for `and`:**
如果 `and` 运算符的左侧表达式为 `False`，那么 Python 会立即判断整个 `and` 表达式的结果为 `False`，而不会去评估右侧的表达式。这被称为短路评估。

**示例：**

```python
x = 0
y = 10

# print(y / x) # 这会引起 ZeroDivisionError

# 使用 and 进行短路评估
if x != 0 and (y / x > 5): # 如果 x 是 0，则 y / x 不会被执行
    print("条件为真")
else:
    print("条件为假或 x 为 0") # 输出: 条件为假或 x 为 0
```

#### 2.2 逻辑或运算符 (`or`)

`or` 运算符也用于连接两个或多个布尔表达式。只要有一个连接的表达式为 `True`，整个表达式的结果就为 `True`；只有当所有连接的表达式都为 `False` 时，结果才为 `False`。

**真值表：**

| 表达式 1 | 表达式 2 | 结果 (表达式 1 `or` 表达式 2) |
| -------- | -------- | ----------------------------- |
| `True`   | `True`   | `True`                        |
| `True`   | `False`  | `True`                        |
| `False`  | `True`   | `True`                        |
| `False`  | `False`  | `False`                       |

**示例：**

```python
is_weekend = False
has_day_off = True

# 条件：是周末 或 有休假
can_relax = is_weekend or has_day_off
print(f"{is_weekend} or {has_day_off} = {can_relax}") # 输出: False or True = True

is_weekend = False
has_day_off = False
can_relax_again = is_weekend or has_day_off
print(f"{is_weekend} or {has_day_off} = {can_relax_again}") # 输出: False or False = False

score = 55
attended_class = True

# 条件：分数及格 (>= 60) 或 出勤良好
can_pass = (score >= 60) or attended_class
print(f"({score} >= 60) or {attended_class} = {can_pass}") # 输出: (55 >= 60) or True = True
```

**短路评估 (Short-circuiting) for `or`:**
如果 `or` 运算符的左侧表达式为 `True`，那么 Python 会立即判断整个 `or` 表达式的结果为 `True`，而不会去评估右侧的表达式。

**示例：**

```python
default_value = ""
user_input = "Hello"

# 如果 user_input 为空，则使用 default_value
final_value = user_input or default_value
print(f"final_value: '{final_value}'") # 输出: final_value: 'Hello'

user_input_empty = ""
final_value_empty = user_input_empty or default_value
print(f"final_value_empty: '{final_value_empty}'") # 输出: final_value_empty: ''
```

#### 2.3 逻辑非运算符 (`not`)

`not` 运算符是一个一元运算符（只作用于一个操作数），它会反转布尔表达式的真假值。如果表达式为 `True`，`not` 会使其变为 `False`；如果表达式为 `False`，`not` 会使其变为 `True`。

**真值表：**

| 表达式 | 结果 (`not` 表达式) |
| ------ | ------------------- |
| `True` | `False`             |
| `False`| `True`              |

**示例：**

```python
is_raining = True
print(f"not {is_raining} = {not is_raining}") # 输出: not True = False

is_hungry = False
print(f"not {is_hungry} = {not is_hungry}") # 输出: not False = True

# 应用于表达式
age = 17
is_adult = age >= 18
print(f"age {age} is_adult: {is_adult}") # 输出: age 17 is_adult: False
print(f"not (age >= 18) = {not (age >= 18)}") # 输出: not (age >= 18) = True (即 not False = True)
```

### 3. 运算符优先级

当一个表达式中包含多个逻辑运算符以及其他运算符时，Python 会遵循特定的运算顺序。优先级从高到低如下：

1.  **算术运算符** (如 `+`, `-`, `*`, `/`, `**` 等)
2.  **比较运算符** (如 `==`, `!=`, `>`, `<`, `>=`, `<=` 等)
3.  **`not`** 运算符
4.  **`and`** 运算符
5.  **`or`** 运算符

**括号 `()`** 总是具有最高优先级，可以用来强制改变运算顺序。

**示例：**

```python
# 示例 1: 比较运算符优先于逻辑运算符
x = 10
y = 5
z = 12

result1 = x > y and y < z # (x > y) (True) and (y < z) (True) -> True and True -> True
print(f"{x} > {y} and {y} < {z} = {result1}") # 输出: 10 > 5 and 5 < 12 = True

# 示例 2: not 优先于 and 和 or
is_active = True
is_admin = False

result2 = not is_active and is_admin # (not is_active) (False) and is_admin (False) -> False and False -> False
print(f"not {is_active} and {is_admin} = {result2}") # 输出: not True and False = False

# 示例 3: 使用括号改变优先级
result3 = not (is_active and is_admin) # (is_active and is_admin) (False)，然后 not False -> True
print(f"not ({is_active} and {is_admin}) = {result3}") # 输出: not (True and False) = True
```

### 4. 逻辑运算符在条件语句中的应用

逻辑运算符最常用于 `if`, `elif`, `else` 语句中，以创建复杂的条件逻辑。

**示例：**

```python
# 模拟用户登录
username = "admin"
password = "password123"
is_logged_in = False

input_username = input("请输入用户名: ")
input_password = input("请输入密码: ")

if input_username == username and input_password == password and not is_logged_in:
    print("登录成功！")
    is_logged_in = True
elif is_logged_in:
    print("您已登录。")
else:
    print("用户名或密码错误。")

# 模拟电影票购买条件
age = int(input("请输入您的年龄: "))
is_student = input("您是学生吗？(y/n): ").lower() == 'y'

if age >= 18 and not is_student:
    print("您需要购买成人票。")
elif age < 18 or is_student: # 小于 18 岁或者学生可以买优惠票
    print("您可以购买优惠票。")
else:
    print("输入无效。")
```

好的，这是一份关于 Python 赋值运算符的教程，不包含总结和练习部分。

## 赋值运算符

在 Python 中，赋值运算符用于将值存储到变量中。除了最基本的 `=` 运算符，Python 还提供了一系列复合赋值运算符，它们结合了算术（或其他）运算和赋值操作，使得代码更加简洁高效。

### 1. 什么是赋值运算符？

赋值运算符用于将右侧表达式的值赋给左侧的变量。

### 2. 基本赋值运算符 (`=`)

`=` 是最常用的赋值运算符。它将右侧的值或表达式的结果赋给左侧的变量。

**语法：** `variable = value`

**示例：**

```python
# 将整数值 10 赋给变量 x
x = 10
print(f"x 的值: {x}") # 输出: x 的值: 10

# 将字符串 "Hello" 赋给变量 greeting
greeting = "Hello"
print(f"greeting 的值: {greeting}") # 输出: greeting 的值: Hello

# 将一个表达式的结果赋给变量
y = 5
z = x + y # x + y 的结果 (15) 赋给 z
print(f"z 的值: {z}") # 输出: z 的值: 15

# 可以同时为多个变量赋值（链式赋值）
a = b = c = 100
print(f"a: {a}, b: {b}, c: {c}") # 输出: a: 100, b: 100, c: 100

# 也可以进行解包赋值（sequence unpacking）
data = [10, 20, 30]
val1, val2, val3 = data
print(f"val1: {val1}, val2: {val2}, val3: {val3}") # 输出: val1: 10, val2: 20, val3: 30
```

### 3. 复合赋值运算符

复合赋值运算符结合了算术（或其他）运算和赋值操作。它们是以下形式的简写：`variable = variable operator expression`。

这些运算符使得代码更简洁，并且在某些情况下可能更高效（尽管现代 Python 解释器对性能的优化使得差异不那么明显）。

#### 3.1 加法赋值 (`+=`)

`a += b` 等同于 `a = a + b`。它将变量 `a` 的值与 `b` 相加，然后将结果重新赋给 `a`。

**示例：**

```python
x = 10
x += 5 # 等同于 x = x + 5
print(f"x += 5 后的值: {x}") # 输出: x += 5 后的值: 15

# 也可以用于字符串拼接
message = "Hello"
message += " World" # 等同于 message = message + " World"
print(f"message += ' World' 后的值: {message}") # 输出: message += ' World' 后的值: Hello World

# 也可以用于列表拼接（扩展列表）
my_list = [1, 2]
my_list += [3, 4] # 等同于 my_list = my_list + [3, 4]
print(f"my_list += [3, 4] 后的值: {my_list}") # 输出: my_list += [3, 4] 后的值: [1, 2, 3, 4]
```

#### 3.2 减法赋值 (`-=`)

`a -= b` 等同于 `a = a - b`。它将变量 `a` 的值减去 `b`，然后将结果重新赋给 `a`。

**示例：**

```python
y = 20
y -= 7 # 等同于 y = y - 7
print(f"y -= 7 后的值: {y}") # 输出: y -= 7 后的值: 13
```

#### 3.3 乘法赋值 (`*=`)

`a *= b` 等同于 `a = a * b`。它将变量 `a` 的值与 `b` 相乘，然后将结果重新赋给 `a`。

**示例：**

```python
z = 5
z *= 4 # 等同于 z = z * 4
print(f"z *= 4 后的值: {z}") # 输出: z *= 4 后的值: 20

# 也可以用于字符串重复
text = "ABC"
text *= 3 # 等同于 text = text * 3
print(f"text *= 3 后的值: {text}") # 输出: text *= 3 后的值: ABCABCABC
```

#### 3.4 除法赋值 (`/=`)

`a /= b` 等同于 `a = a / b`。它将变量 `a` 的值除以 `b`，然后将结果重新赋给 `a`。
**注意：** 结果总是浮点数。

**示例：**

```python
m = 25
m /= 5 # 等同于 m = m / 5
print(f"m /= 5 后的值: {m}") # 输出: m /= 5 后的值: 5.0

n = 10
n /= 3 # 等同于 n = n / 3
print(f"n /= 3 后的值: {n}") # 输出: n /= 3 后的值: 3.3333333333333335
```

#### 3.5 整除赋值 (`//=`)

`a //= b` 等同于 `a = a // b`。它将变量 `a` 的值整除 `b`，然后将结果重新赋给 `a`。

**示例：**

```python
p = 17
p //= 3 # 等同于 p = p // 3
print(f"p //= 3 后的值: {p}") # 输出: p //= 3 后的值: 5

q = -10
q //= 3 # 等同于 q = q // 3
print(f"q //= 3 后的值: {q}") # 输出: q //= 3 后的值: -4
```

#### 3.6 取模赋值 (`%=`)

`a %= b` 等同于 `a = a % b`。它将变量 `a` 的值对 `b` 取模，然后将结果重新赋给 `a`。

**示例：**

```python
r = 27
r %= 5 # 等同于 r = r % 5
print(f"r %= 5 后的值: {r}") # 输出: r %= 5 后的值: 2
```

#### 3.7 幂赋值 (`**=`)

`a **= b` 等同于 `a = a ** b`。它将变量 `a` 的值进行 `b` 次幂运算，然后将结果重新赋给 `a`。

**示例：**

```python
s = 2
s **= 3 # 等同于 s = s ** 3 (2 的 3 次方)
print(f"s **= 3 后的值: {s}") # 输出: s **= 3 后的值: 8
```

#### 3.8 位运算符复合赋值 (了解即可)

除了算术复合赋值，Python 还有用于位运算的复合赋值运算符。这些通常在处理二进制数据或进行底层操作时使用。

* `&=` (按位与赋值)
* `|=` (按位或赋值)
* `^=` (按位异或赋值)
* `>>=` (右移赋值)
* `<<=` (左移赋值)

**示例 (位运算符复合赋值)：**

```python
# 按位与赋值
bit_val = 10 # 二进制 1010
bit_val &= 3 # 二进制 0011 (1010 & 0011 = 0010)
print(f"bit_val &= 3 后的值: {bit_val}") # 输出: 2

# 左移赋值
shift_val = 5 # 二进制 0101
shift_val <<= 1 # 左移一位 (01010) 等于 10
print(f"shift_val <<= 1 后的值: {shift_val}") # 输出: 10
```

### 4. 赋值表达式 (Python 3.8+ `:=` 海象运算符)

自 Python 3.8 起，引入了赋值表达式 (`:=`)，也常被称为“海象运算符”（因为它看起来像一只海象）。它允许你在表达式内部进行变量赋值。这与赋值语句 `=` 不同，`=` 是一个语句，不能在表达式中使用。

**语法：** `(variable := expression)`

**示例：**

```python
# 传统方式
# data = [1, 2, 3]
# n = len(data)
# if n > 0:
#     print(f "列表长度为: {n}")

# 使用海象运算符
data = [1, 2, 3]
if (n := len(data)) > 0: # 在 if 条件中同时赋值和判断
    print(f"列表长度为: {n}") # 输出: 列表长度为: 3

# 在列表推导式中使用
# scores = [80, 75, 90, 60]
# pass_threshold = 70
# passed_scores = [score for score in scores if score >= pass_threshold]
# print(f "及格分数: {passed_scores}")

# 使用海象运算符改进
scores = [80, 75, 90, 60]
if any((score := s) >= 90 for s in scores): # 赋值 score 为符合条件的 s
    print(f"有至少一个分数达到 90 或更高，其中一个分数是: {score}") # 这里 score 会是最后一个满足条件的值

# 简化 while 循环
# while True:
#     command = input("请输入命令 (输入 'exit' 退出): ")
#     if command == 'exit':
#         break
#     print(f "执行命令: {command}")

# 使用海象运算符
while (command := input("请输入命令 (输入 'exit' 退出): ")) != 'exit':
    print(f"执行命令: {command}")
```

海象运算符在某些场景下可以提高代码的简洁性和可读性，但应谨慎使用，避免过度复杂化表达式。

好的，这是一份关于 Python 成员运算符的教程，不包含总结和练习部分。

## 成员运算符

在 Python 中，成员运算符用于测试序列（如字符串、列表、元组）或集合中是否包含某个特定值。它们在检查元素是否存在于集合或序列中时非常有用。

### 1. 什么是成员运算符？

成员运算符用于检查一个值是否是某个序列（或集合、字典的键）的成员。它们总是返回布尔值 `True` 或 `False`。

### 2. Python 中的成员运算符

Python 提供了两个成员运算符：`in` 和 `not in`。

#### 2.1 成员运算符 (`in`)

`in` 运算符用于检查左侧的操作数（一个值）是否存在于右侧的操作数（一个序列、集合或字典的键）中。如果存在，则返回 `True`；否则，返回 `False`。

**语法：** `value in sequence`

**适用于：**
* **字符串：** 检查子字符串是否存在于字符串中。
* **列表：** 检查元素是否存在于列表中。
* **元组：** 检查元素是否存在于元组中。
* **集合：** 检查元素是否存在于集合中。
* **字典：** 检查键是否存在于字典中（不检查值）。

**示例：**

```python
# 检查字符串中的子字符串
text = "Hello, Python!"
print(f"'Python' in '{text}' 结果: {'Python' in text}") # 输出: True
print(f"'Java' in '{text}' 结果: {'Java' in text}")     # 输出: False
print(f"'hello' in '{text}' 结果: {'hello' in text}")   # 输出: False (大小写敏感)

# 检查列表中是否存在元素
my_list = [10, 20, 30, 40]
print(f"20 in {my_list} 结果: {20 in my_list}")   # 输出: True
print(f"50 in {my_list} 结果: {50 in my_list}")   # 输出: False

# 检查元组中是否存在元素
my_tuple = ('apple', 'banana', 'cherry')
print(f"'banana' in {my_tuple} 结果: {'banana' in my_tuple}") # 输出: True
print(f"'grape' in {my_tuple} 结果: {'grape' in my_tuple}")   # 输出: False

# 检查集合中是否存在元素
my_set = {1, 2, 3, 4}
print(f"3 in {my_set} 结果: {3 in my_set}") # 输出: True
print(f"5 in {my_set} 结果: {5 in my_set}") # 输出: False

# 检查字典中是否存在键
my_dict = {'name': 'Alice', 'age': 30, 'city': 'New York'}
print(f"'age' in {my_dict} 结果: {'age' in my_dict}") # 输出: True (检查键)
print(f"'country' in {my_dict} 结果: {'country' in my_dict}") # 输出: False (检查键)
print(f"30 in {my_dict} 结果: {30 in my_dict}") # 输出: False (不直接检查值)

# 如果想检查字典的值，你需要遍历字典的值：
print(f"30 in {my_dict.values()} 结果: {30 in my_dict.values()}") # 输出: True
```

#### 2.2 非成员运算符 (`not in`)

`not in` 运算符是 `in` 运算符的反义。它用于检查左侧的操作数（一个值）是否 **不** 存在于右侧的操作数（一个序列、集合或字典的键）中。如果不存在，则返回 `True`；否则，返回 `False`。

**语法：** `value not in sequence`

**示例：**

```python
# 检查字符串中不存在的子字符串
text = "Programming is fun!"
print(f"'Java' not in '{text}' 结果: {'Java' not in text}") # 输出: True
print(f"'fun' not in '{text}' 结果: {'fun' not in text}")   # 输出: False

# 检查列表中不存在的元素
numbers = [100, 200, 300]
print(f"50 not in {numbers} 结果: {50 not in numbers}")     # 输出: True
print(f"200 not in {numbers} 结果: {200 not in numbers}")   # 输出: False

# 检查字典中不存在的键
student_info = {'id': 101, 'major': 'CS'}
print(f"'grade' not in {student_info} 结果: {'grade' not in student_info}") # 输出: True
print(f"'id' not in {student_info} 结果: {'id' not in student_info}")     # 输出: False
```

### 3. 应用场景

成员运算符在日常编程中非常常见，尤其是在条件判断、数据验证和过滤时。

* **条件判断：**
    ```python
    user_role = "admin"
    if user_role in ["admin", "moderator"]:
        print("用户有管理权限。")
    ```

* **数据验证：**
    ```python
    valid_colors = ['red', 'green', 'blue']
    user_color = input("请输入您喜欢的颜色: ")
    if user_color.lower() not in valid_colors:
        print("输入的颜色无效。")
    else:
        print(f"您选择了 {user_color}。")
    ```

* **循环和搜索：**
    ```python
    sentence = "The quick brown fox jumps over the lazy dog."
    if "fox" in sentence:
        print("句子中包含 'fox'。")
    
    # 查找特定字符
    vowels = "aeiouAEIOU"
    char_to_check = 'P'
    if char_to_check in vowels:
        print(f"'{char_to_check}' 是一个元音字母。")
    else:
        print(f"'{char_to_check}' 不是一个元音字母。")
    ```

成员运算符在处理集合数据时效率很高，因为集合是为快速成员查找而优化的（平均时间复杂度为 O(1)）。对于列表和元组等序列，成员查找的时间复杂度通常是 O(n)，即与序列的长度成正比。
好的，这是一份关于 Python 身份运算符的教程，不包含总结和练习部分。

## 身份运算符

在 Python 中，除了比较值是否相等之外，有时还需要判断两个变量是否引用了内存中的同一个对象。这时就需要用到身份运算符。身份运算符关注的是对象的内存地址，而不是对象的值。

### 1. 什么是身份运算符？

身份运算符用于检查两个变量是否指向（引用）内存中的同一个对象。它们总是返回布尔值 `True` 或 `False`。

### 2. Python 中的身份运算符

Python 提供了两个身份运算符：`is` 和 `is not`。

#### 2.1 身份运算符 (`is`)

`is` 运算符用于检查左侧的操作数和右侧的操作数是否指向内存中的同一个对象。如果它们是同一个对象，则返回 `True`；否则，返回 `False`。

**语法：** `object1 is object2`

**重要说明：**

* **`is` 与 `==` 的区别：**
    * `is` 比较的是两个变量的 **身份（identity）**，即它们在内存中的存储地址是否相同。
    * `==` 比较的是两个变量的 **值（value）**，即它们所表示的数据内容是否相等。

* **小整数缓存（Integer Caching）/字符串驻留（String Interning）：**
    Python 解释器为了优化性能，会对一些常用的、不可变的对象（如小整数：通常是 -5 到 256 之间的整数；短字符串）进行缓存或驻留。这意味着在这些范围内的相同值可能实际上指向同一个内存对象。超出这个范围，即使值相同，也可能创建不同的对象。

**示例：**

```python
# 比较整数
a = 10
b = 10
c = 20

print(f"{a} is {b} 结果: {a is b}") # 输出: True (因为 10 在小整数缓存范围内)
print(f"{a} == {b} 结果: {a == b}") # 输出: True

print(f"{a} is {c} 结果: {a is c}") # 输出: False
print(f"{a} == {c} 结果: {a == c}") # 输出: False

# 比较超出缓存范围的整数
x = 300
y = 300
print(f"{x} is {y} 结果: {x is y}") # 输出: False (通常情况下，因为 300 超出缓存范围，会创建两个不同的对象)
print(f"{x} == {y} 结果: {x == y}") # 输出: True

# 比较字符串
str1 = "hello"
str2 = "hello"
str3 = "world"

print(f"'{str1}' is '{str2}' 结果: {str1 is str2}") # 输出: True (短字符串通常会被驻留，指向同一个对象)
print(f"'{str1}' == '{str2}' 结果: {str1 == str2}") # 输出: True

str4 = "这是一个比较长的字符串，可能不会被驻留"
str5 = "这是一个比较长的字符串，可能不会被驻留"
print(f"'{str4}' is '{str5}' 结果: {str4 is str5}") # 输出: False (长字符串通常不会被驻留，除非是字面量或由编译器优化)
print(f"'{str4}' == '{str5}' 结果: {str4 == str5}") # 输出: True

# 比较列表 (可变对象，通常总是创建新对象)
list1 = [1, 2, 3]
list2 = [1, 2, 3]
list3 = list1 # list3 引用了 list1 指向的同一个对象

print(f"{list1} is {list2} 结果: {list1 is list2}") # 输出: False (两个不同的列表对象，即使值相同)
print(f"{list1} == {list2} 结果: {list1 == list2}") # 输出: True (值相等)

print(f"{list1} is {list3} 结果: {list1 is list3}") # 输出: True (它们引用了同一个对象)
print(f"{list1} == {list3} 结果: {list1 == list3}") # 输出: True

# 比较 None
# None 在 Python 中是唯一的单例对象
val_none = None
another_none = None
print(f"{val_none} is {another_none} 结果: {val_none is another_none}") # 输出: True
print(f"{val_none} == {another_none} 结果: {val_none == another_none}") # 输出: True

# 检查布尔值
bool1 = True
bool2 = True
bool3 = False
print(f"{bool1} is {bool2} 结果: {bool1 is bool2}") # 输出: True (True 和 False 也是单例对象)
print(f"{bool1} is {bool3} 结果: {bool1 is bool3}") # 输出: False
```

#### 2.2 身份非运算符 (`is not`)

`is not` 运算符是 `is` 运算符的反义。它用于检查左侧的操作数和右侧的操作数是否 **不** 指向内存中的同一个对象。如果它们不是同一个对象，则返回 `True`；否则，返回 `False`。

**语法：** `object1 is not object2`

**示例：**

```python
list_a = [1, 2]
list_b = [1, 2]
list_c = list_a

print(f"{list_a} is not {list_b} 结果: {list_a is not list_b}") # 输出: True (是两个不同的对象)
print(f"{list_a} is not {list_c} 结果: {list_a is not list_c}") # 输出: False (是同一个对象)

# 结合 None
user_input = None
if user_input is not None:
    print("用户输入了内容。")
else:
    print("用户输入为空。")
```

### 3. 应用场景

`is` 和 `is not` 运算符在以下场景中特别有用：

* **检查是否为 `None`：** 这是 `is` 运算符最常见的用法。由于 `None` 是一个单例对象，始终推荐使用 `is None` 和 `is not None` 来检查变量是否为空，而不是 `== None`。
    ```python
    my_variable = None
    if my_variable is None:
        print("变量为空。")
    ```

* **判断两个变量是否引用同一个可变对象：** 当你想确保对一个变量的修改也会影响到另一个变量时，或者想避免意外修改共享对象时，使用 `is` 可以进行精确判断。
    ```python
    data1 = [10, 20]
    data2 = data1 # data2 和 data1 引用同一个列表对象
    data3 = [10, 20] # data3 是一个新的列表对象
    
    print(data1 is data2) # True
    print(data1 is data3) # False
    
    data1.append(30)
    print(data2) # 输出: [10, 20, 30] (data2 也变了，因为它们是同一个对象)
    print(data3) # 输出: [10, 20] (data3 没变)
    ```

* **性能考虑（对于单例对象）：** 对于像 `None`, `True`, `False` 和小整数这样的单例或缓存对象，`is` 运算符比 `==` 运算符通常效率更高，因为它只需要比较内存地址，而 `==` 可能需要执行更复杂的比较逻辑（取决于对象的 `__eq__` 方法）。

### 4. `id()` 函数

Python 提供了一个内置函数 `id()`，它可以返回对象的“身份”值，这个值通常是对象在内存中的地址。你可以使用 `id()` 来直观地理解 `is` 运算符的工作原理。

**示例：**

```python
list_a = [1, 2, 3]
list_b = [1, 2, 3]
list_c = list_a

print(f"id(list_a): {id(list_a)}")
print(f"id(list_b): {id(list_b)}")
print(f"id(list_c): {id(list_c)}")

print(f"list_a is list_b: {list_a is list_b}") # False，id 不同
print(f"list_a is list_c: {list_a is list_c}") # True，id 相同
```

**注意：** `id()` 返回的身份值在程序的整个生命周期内是唯一的（对于活动的同一对象而言），但不同次运行程序时可能会不同。
好的，这是一份关于如何在 Python 中使用 `input()` 函数获取用户输入的教程，不包含总结和练习部分。

## `input()` 函数：获取用户输入

在交互式程序中，从用户那里获取数据是非常常见的需求。Python 的内置函数 `input()` 专门用于实现这一功能，它允许程序在运行时暂停，等待用户在控制台中键入内容并按回车。

### 1. `input()` 函数的基本用法

`input()` 函数会从标准输入（通常是键盘）读取一行文本，直到遇到换行符（用户按下回车键）。它总是将读取到的内容作为 **字符串** 返回。

**语法：** `input([prompt])`

* `prompt` (可选参数)：一个字符串，作为提示信息显示给用户。这个提示会在用户输入之前打印到控制台，告诉用户需要输入什么。

**示例 1：最简单的用法**

```python
# 程序会暂停，等待用户输入
user_data = input()
print(f"您输入了: {user_data}")
```

当你运行这段代码时，控制台会显示一个光标，等待你输入。输入“Hello World”并按回车后，输出会是：

```
Hello World
您输入了: Hello World
```

**示例 2：带提示信息的用法**

为了让用户知道需要输入什么，通常会提供一个提示信息。

```python
name = input("请输入您的名字: ")
print(f"您好, {name}!")
```

运行这段代码：

```
请输入您的名字: Alice
您好, Alice!
```

**示例 3：获取数字输入并进行转换**

正如之前数据类型转换教程中提到的，`input()` 总是返回字符串。如果需要获取数字进行计算，就必须进行类型转换。

```python
# 获取用户的年龄
age_str = input("请输入您的年龄: ")

# 将字符串转换为整数
# 注意：如果用户输入了非数字字符，这里会发生 ValueError
try:
    age_int = int(age_str)
    print(f"您的年龄是: {age_int} 岁。")
    print(f"再过一年您将是: {age_int + 1} 岁。")
except ValueError:
    print("输入的年龄无效，请确保输入的是一个整数。")

# 获取用户的身高（可能是浮点数）
height_str = input("请输入您的身高（米）: ")
try:
    height_float = float(height_str)
    print(f"您的身高是: {height_float} 米。")
except ValueError:
    print("输入的身高无效，请确保输入的是一个数字。")
```

### 2. `input()` 函数的特点和注意事项

* **返回值总是字符串：** 这是最重要的特点。即使你输入了数字 `123`，`input()` 返回的也是字符串 `"123"`。
* **阻塞程序执行：** `input()` 函数会暂停程序的执行，直到用户输入内容并按下 `Enter` 键。
* **不接受参数作为实际输入：** `input()` 函数的参数只是一个提示，它本身不会作为用户输入的一部分被读取。
* **错误处理：** 当你期望用户输入特定类型的数据（如整数、浮点数）时，最好使用 `try-except` 块来处理 `ValueError`，以防止用户输入不符合预期的数据类型而导致程序崩溃。

### 3. 多次获取用户输入

你可以在程序中多次使用 `input()` 来获取不同的信息。

**示例 4：获取多个用户信息**

```python
print("请填写以下信息：")
full_name = input("姓名: ")
email = input("邮箱: ")
phone = input("电话: ")

print("\n--- 您的信息摘要 ---")
print(f"姓名: {full_name}")
print(f"邮箱: {email}")
print(f"电话: {phone}")
```

### 4. 结合 `if` 语句和循环

`input()` 函数经常与条件语句 (`if`/`elif`/`else`) 和循环 (`while`) 结合使用，以创建更复杂的交互式程序。

**示例 5：简单的命令行选择**

```python
while True:
    command = input("请输入命令 ('开始', '停止', '退出'): ").lower() # 将输入转换为小写方便比较

    if command == "开始":
        print("程序已启动。")
    elif command == "停止":
        print("程序已停止。")
    elif command == "退出":
        print("程序已退出。")
        break # 退出循环
    else:
        print("无效命令，请重新输入。")
```

这个例子展示了如何在一个无限循环中反复获取用户输入，并根据输入执行不同的操作，直到用户输入“退出”才结束。
好的，这是一份关于如何在 Python 中使用 `print()` 函数输出结果的教程。

## `print()` 函数

在编程中，将信息显示给用户或在调试时查看变量的值是必不可少的。Python 的内置函数 `print()` 就是为此目的而生，它是你学习 Python 时最早接触也最常用的函数之一。

### 1. `print()` 函数的基本用法

`print()` 函数最简单的用法是直接在括号内放入你想要输出的内容。它会将内容显示到标准输出（通常是控制台或终端），并在输出末尾自动添加一个换行符。

**语法：** `print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)`

虽然 `print()` 有多个参数，但我们先从最常用的开始。

#### 1.1 输出单个值

你可以打印数字、字符串、变量等任何类型的值。

**示例 1：**

```python
print("Hello, Python!") # 输出字符串
print(123)            # 输出整数
print(3.14159)        # 输出浮点数

name = "Alice"
age = 30
print(name)           # 输出变量的值
print(age)            # 输出变量的值
```

运行这些代码会得到以下输出：

```
Hello, Python!
123
3.14159
Alice
30
```

#### 1.2 输出多个值

`print()` 函数可以接受多个值作为参数，它们之间用逗号 `,` 分隔。默认情况下，这些值之间会用一个空格作为分隔符。

**示例 2：**

```python
print("My name is", name, "and I am", age, "years old.")
# 输出: My name is Alice and I am 30 years old.

city = "New York"
temp = 25.5
print("Current city:", city, "Temperature:", temp, "degrees Celsius.")
# 输出: Current city: New York Temperature: 25.5 degrees Celsius.
```

### 2. `print()` 函数的常用参数

`print()` 函数的强大之处在于它的可选参数，它们允许你更精细地控制输出格式。

---

#### 2.1 `sep` 参数 (Separator)

`sep` 参数用于指定在打印多个值时，它们之间使用的分隔符。默认值是单个空格 `' '`。

**示例 3：**

```python
print("apple", "banana", "cherry")         # 默认分隔符是空格
# 输出: apple banana cherry

print("apple", "banana", "cherry", sep="-") # 使用连字符作为分隔符
# 输出: apple-banana-cherry

print("192", "168", "1", "1", sep=".")     # 打印 IP 地址
# 输出: 192.168.1.1

date_day = 10
date_month = 6
date_year = 2025
print(date_year, date_month, date_day, sep="/") # 打印日期
# 输出: 2025/6/10
```

---

#### 2.2 `end` 参数 (End)

`end` 参数用于指定 `print()` 函数在输出所有内容后，在末尾添加的字符。默认值是换行符 `'\n'`。通过改变 `end` 的值，你可以控制连续的 `print()` 语句是否在新的一行开始。

**示例 4：**

```python
print("This is the first line.")
print("This is the second line.")
# 默认情况下，每次 print 都会换行

print("Hello", end=" ") # 不换行，以空格结尾
print("World!")         # 接着上面的 "Hello " 后面打印
# 输出: Hello World!

print("Counting: ", end="")
for i in range(1, 6):
    print(i, end="...") # 每次打印一个数字，后面跟着 "..."
print("Done!")         # 最后打印 Done! 并换行
# 输出: Counting: 1...2...3...4...5...Done!
```

---

### 3. 使用 F-string (格式化字符串字面量) 进行输出

从 Python 3.6 开始，**F-string (Formatted String Literals)** 是推荐的字符串格式化方法，它提供了一种简洁易读的方式来嵌入表达式。F-string 以 `f` 或 `F` 开头，后面跟着一个字符串，其中可以包含用花括号 `{}` 包裹的表达式。

F-string 不仅仅是 `print()` 函数的参数，它是一种字符串本身。但它与 `print()` 结合使用时效果最佳。

**示例 5：**

```python
item = "Laptop"
price = 1200
quantity = 2

# 传统字符串拼接（不推荐，可读性差）
# print("The " + item + " costs " + str(price) + " and we have " + str(quantity) + " in stock.")

# 使用 F-string
print(f"The {item} costs ${price} and we have {quantity} in stock.")
# 输出: The Laptop costs $1200 and we have 2 in stock.

total_cost = price * quantity
print(f"Total cost for {quantity} {item}s: ${total_cost}.")
# 输出: Total cost for 2 Laptops: $2400.

# F-string 中可以直接进行表达式计算
print(f"Next year, {name} will be {age + 1} years old.")
# 输出: Next year, Alice will be 31 years old.

# F-string 中可以使用格式化说明符
pi = 3.1415926535
print(f"Pi to 2 decimal places: {pi:.2f}") # .2f 表示保留两位小数的浮点数
# 输出: Pi to 2 decimal places: 3.14

percentage = 0.75
print(f"Completion: {percentage:.0%}") # .0% 表示不带小数的百分比
# 输出: Completion: 75%
```

F-string 是目前最推荐的字符串格式化方式，因为它既简洁又强大，并且易于阅读。

---

### 4. 其他不常用参数 (了解即可)

* **`file` 参数：** 默认情况下，`print()` 函数会将输出发送到标准输出流 (`sys.stdout`)。你可以通过 `file` 参数将其重定向到任何文件对象，例如写入一个文件。
    ```python
    import sys
    
    # 打印到文件 (而不是控制台)
    with open("output.txt", "w") as f:
        print("This message will be written to output.txt", file=f)
    print("This message goes to console.")
    ```

* **`flush` 参数：** 默认情况下，`print()` 函数的输出通常是缓冲的，这意味着它不会立即显示在屏幕上，而是在缓冲区满了或者程序结束时才一次性显示。将 `flush` 设置为 `True` 会强制立即清空缓冲区，使内容立即显示。这在实时进度更新或调试时可能有用。
    ```python
    import time
    
    print("Starting countdown: ", end="", flush=True)
    for i in range(5, 0, -1):
        print(i, end=" ", flush=True)
        time.sleep(0.5) # 暂停 0.5 秒
    print("Lift off!")
    ```


好的，这是一份关于 `print()` 函数的格式化输出教程，重点讲解 f-strings 和 `.format()` 方法。

## f-strings 与 `.format()`

在 Python 中，仅仅打印变量的值通常是不够的。我们经常需要将变量值嵌入到预定义的文本中，并以特定的格式（如小数位数、对齐方式、千位分隔符等）显示它们。Python 提供了多种字符串格式化方法，其中 f-strings 和 `.format()` 方法是目前最常用和推荐的两种。

### 1. 为什么需要格式化输出？

* **可读性：** 使输出信息更清晰、更易于人类阅读。
* **一致性：** 确保数字、日期等以统一的格式显示。
* **数据呈现：** 满足特定报告或界面对数据格式的要求。
* **调试：** 在打印变量时包含上下文信息，有助于快速定位问题。

### 2. F-strings (格式化字符串字面量) - Python 3.6+ 推荐

F-strings 是从 Python 3.6 版本引入的一种字符串格式化方式，它以其简洁、强大和高性能而迅速成为最受欢迎的方法。

**语法：** 在字符串前加上 `f` 或 `F`，然后用花括号 `{}` 包裹你想要嵌入的变量或表达式。

#### 2.1 基本用法：嵌入变量和表达式

```python
name = "Alice"
age = 30
salary = 5000.75

# 嵌入变量
print(f"My name is {name} and I am {age} years old.")
# 输出: My name is Alice and I am 30 years old.

# 嵌入表达式
print(f"Next year, {name} will be {age + 1} years old.")
# 输出: Next year, Alice will be 31 years old.

# 可以直接进行简单的运算
print(f"Monthly salary: ${salary}, Annual salary: ${salary * 12}.")
# 输出: Monthly salary: $5000.75, Annual salary: $60009.0.

# 嵌入函数调用
print(f"Name in uppercase: {name.upper()}")
# 输出: Name in uppercase: ALICE
```

#### 2.2 格式化说明符 (Format Specifiers)

F-strings 的强大之处在于可以在花括号内使用“格式化迷你语言”（Format Specification Mini-Language）来控制输出的格式。格式化说明符位于冒号 `:` 之后。

**通用格式：** `{value:format_specifier}`

**常用格式说明符：**

* **精度和浮点数：**
    * `.nf`: 保留 `n` 位小数的浮点数。
    * `%`: 百分比格式。

    ```python
    pi = 3.1415926535
    print(f"Pi (2 decimal places): {pi:.2f}")  # 输出: Pi (2 decimal places): 3.14
    print(f"Pi (4 decimal places): {pi:.4f}")  # 输出: Pi (4 decimal places): 3.1416 (四舍五入)
    
    progress = 0.857
    print(f"Progress: {progress:.2%}")         # 输出: Progress: 85.70%
    print(f"Progress (no decimals): {progress:.0%}") # 输出: Progress (no decimals): 86%
    ```

* **对齐和填充：**
    * `<`: 左对齐
    * `>`: 右对齐
    * `^`: 居中对齐
    * `width`: 总宽度
    * `fill_char`: 填充字符 (默认为空格，`fill_char` 必须在对齐符号之前)

    ```python
    item = "Book"
    price = 25.99
    
    print(f"|{item:<10}|{price:>10.2f}|") # 左对齐 item (10宽), 右对齐 price (10宽, 2小数)
    # 输出: |Book      |     25.99|
    
    print(f"|{item:^10}|{price:^10.2f}|") # 居中对齐
    # 输出: |   Book   |   25.99  |
    
    # 使用填充字符
    print(f"|{item:*^10}|") # 以 '*' 填充，居中对齐，总宽 10
    # 输出: |***Book***|
    ```

* **数字格式：**
    * `d`: 整数 (decimal)
    * `f`: 浮点数 (float)
    * `,` (逗号): 千位分隔符

    ```python
    large_number = 123456789
    print(f"Large number: {large_number:,}") # 输出: Large number: 123,456,789
    
    balance = 1234.56
    print(f"Balance: ${balance:,.2f}") # 输出: Balance: $1,234.56
    ```

* **不同进制：**
    * `b`: 二进制
    * `o`: 八进制
    * `x` / `X`: 十六进制 (小写/大写)

    ```python
    num = 255
    print(f"Decimal: {num}")         # 输出: Decimal: 255
    print(f"Binary: {num:b}")        # 输出: Binary: 11111111
    print(f"Octal: {num:o}")         # 输出: Octal: 377
    print(f"Hexadecimal: {num:x}")   # 输出: Hexadecimal: ff
    print(f"Hexadecimal (upper): {num:X}") # 输出: Hexadecimal (upper): FF
    ```

* **显示符号：**
    * `+`: 始终显示符号（正数显示 `+`，负数显示 `-`）
    * ` `: 正数前加空格，负数前加 `-`

    ```python
    pos_num = 10
    neg_num = -5
    print(f"Positive: {pos_num:+d}, Negative: {neg_num:+d}") # 输出: Positive: +10, Negative: -5
    print(f"Positive: {pos_num: d}, Negative: {neg_num: d}") # 输出: Positive:  10, Negative: -5
    ```

#### 2.3 F-string 的调试功能 (Python 3.8+)

从 Python 3.8 开始，f-strings 提供了方便的调试功能，通过在变量名后添加 `=` 来同时打印变量名和其值。

```python
user = "Bob"
age = 42

print(f"{user=}")   # 输出: user='Bob'
print(f"{age=}")    # 输出: age=42

# 结合其他格式化
price = 99.99
print(f"{price=:.2f}") # 输出: price=99.99
```

### 3. `.format()` 方法 (Python 2.6+ 推荐)

`.format()` 方法是 f-strings 之前最推荐的格式化字符串的方式。它也使用花括号 `{}` 作为占位符，但变量或值是在 `.format()` 方法中作为参数传入的。

**语法：** `string.format(value1, value2, ...)`

#### 3.1 位置参数格式化

按传入 `.format()` 方法的顺序对应占位符 `{}`。

```python
item = "Monitor"
price = 300
print("The {} costs ${}.".format(item, price))
# 输出: The Monitor costs $300.

# 可以通过索引指定位置
print("The {1} costs ${0}.".format(price, item)) # {1} 对应 item, {0} 对应 price
# 输出: The Monitor costs $300.
```

#### 3.2 关键字参数格式化

通过在占位符中指定关键字名称，并在 `.format()` 方法中以关键字参数的形式传入。这提高了可读性，尤其是在有多个参数时。

```python
print("My name is {name} and I am {age} years old.".format(name="David", age=25))
# 输出: My name is David and I am 25 years old.

# 结合位置参数和关键字参数 (关键字参数必须在位置参数之后)
print("Product: {0}, Quantity: {qty}, Price: {price}.".format("Keyboard", qty=5, price=75.50))
# 输出: Product: Keyboard, Quantity: 5, Price: 75.5.
```

#### 3.3 格式化说明符 (`.format()` 版)

`.format()` 方法也支持与 f-strings 相同的格式化迷你语言。格式化说明符同样在冒号 `:` 之后。

```python
pi = 3.1415926535
print("Pi (2 decimal places): {:.2f}".format(pi))
# 输出: Pi (2 decimal places): 3.14

large_num = 987654321
print("Large number with comma: {:,}".format(large_num))
# 输出: Large number with comma: 987,654,321

width = 15
value = "Center"
print("|{:^15}|".format(value)) # 居中对齐，总宽 15
# 输出: |   Center      |

percentage = 0.45
print("Completion: {:.0%}".format(percentage))
# 输出: Completion: 45%
```

### 4. 选择哪种格式化方法？

* **推荐：F-strings (Python 3.6+)**
    * **优点：** 最简洁、最直观、性能最好。直接在字符串中嵌入变量和表达式，所见即所得。
    * **缺点：** 仅适用于 Python 3.6 及更高版本。
    * **场景：** 大多数新项目和支持 Python 3.6+ 的环境。

* **良好选择：`.format()` 方法**
    * **优点：** 兼容性好（Python 2.6+），功能强大，可读性也不错。
    * **缺点：** 相比 f-strings 稍微啰嗦一些，需要分别定义字符串和参数。
    * **场景：** 需要兼容旧版 Python 的项目，或者个人偏好。

* **不推荐 (了解即可)：`%` 运算符 (旧式格式化)**
    * **优点：** 最古老的格式化方式，兼容所有 Python 版本。
    * **缺点：** 语法复杂，容易出错，可读性差，不如 f-strings 和 `.format()` 灵活。
    * **场景：** 维护非常老的 Python 2 代码。

    ```python
    # 示例: % 运算符 (不推荐在新代码中使用)
    name = "Charlie"
    age = 40
    print("My name is %s and I am %d years old." % (name, age))
    # %s 用于字符串，%d 用于整数
    ```

总之，对于现代 Python 开发，强烈推荐使用 **f-strings** 进行字符串格式化。如果需要考虑旧版本兼容性，`.format()` 方法是一个很好的替代方案。

---